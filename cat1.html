<!doctype html>
<html lang="ja">

	<head>
		<meta charset="utf-8">

    <title>圏論勉強会 第1回 @ ワークスアプリケーションズ</title>

		<meta name="description" content="Seminar of category theory">
    <meta name="author" content="Koichi Nakamura">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

    <meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        }
      });
    </script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

        <section>
        <h1>圏論勉強会<br>第1回</h1>
        <h3>@ワークスアプリケーションズ</h3>
        <small> 中村晃一 <br> 2013年5月16日</small>
        </section>

        <section>
        <h3>謝辞</h3>
        <p>
        この勉強会の企画，会場設備の提供をして頂きました<br>
        &#12849; ワークスアプリケーションズ<br>
        様にこの場をお借りして御礼申し上げます。
        </p>
        </section>

        <section>
        <h3> 自己紹介 </h3>
        <ul>
          <li> 中村晃一</li>
          <li> 東京大学大学院情報理工学系研究科コンピュータ科学専攻<br>
               後期博士課程2年</li>
          <li> プログラム最適化・言語処理系の実装技術・人間と言語の関係等に興味があります。</li>
          <li> twitter: <a href="http://twitter.com/9_ties">@9_ties</a></li>
        </ul>
        </section>

        <section>
        <h2> はじめに </h2>
        </section>

        <section>
        <h3> この会について </h3>
        <ul>
          <li> <span style="color:red">圏論(category theory)</span>を題材にいろんなことを学びます。</li>
          <li> 計算機科学関係の話題が多めになると思います。</li>
          <li> 毎週1回，全12週くらいの予定です。</li>
          <li> 何らかの関数型言語に触れていた方が今後の授業をより楽しめると思います。</li>
          <li> 質問・コメント大歓迎です。他の聴衆の為にもなるので後回しにせずその場でどうぞ。</li>
          <li> この資料は<a href="http://github.com/nineties/category-seminar">http://github.com/nineties/category-seminar</a>に置いてあります。</li>
        </ul>
        </section>

        <section>
        <h3> 参考書 </h3>
        <ul>
          <li> Steve Awodey著 Category Theory をお薦めします。</li>
          <li> 非数学専攻者向けに書かれています。</li>
          <a href="http://www.andrew.cmu.edu/course/80-413-713/notes/">
          http://www.andrew.cmu.edu/course/80-413-713/notes/
          </a>
        </ul>
        <div align="center"><img height="50%" src="http://images-jp.amazon.com/images/P/0199237182" alt='Awodey "Category Theory'></div>
        </section>

        <section>
        <h2> 第１回:圏論って何? </h2>
        </section>

        <section>
        <h3> 第1回の内容</h3>
        <p>
        初回はあまりテクニカルな話をせず、圏論の全体像をつかむ為の話をします。
        </p>
        <ul>
          <li> 圏論って何？ </li>
          <li> 圏論って何の役に立つの? </li>
          <li> 圏論ってどう勉強するの? </li>
          <li> 圏論って学ぶ価値があるの? </li>
        </ul>
        </section>

        <section>
        <h3> 具体例から始めよう </h3>
        </section>
        <section>
        <p>
        問: データ型$A$,$B$が与えられているとします。<br>
        $A$と$B$の<span style="color:red">対(pair)</span>を表すデータ型Pをどう定義すれば良いでしょうか？
        </p>
        <pre class="fragment"><code contenteditable>
/* C言語での例 */
struct P {
  A first;
  B second;
};

他にもいろいろ考えて下さい。
        </code></pre>
        </section>

        <section>
        <h3> 「対」って何? </h3>
        <p>
        「$A$,$B$の対」とみなせる、多くの具体的な定義があります。一方
        </p>
        <pre><code contenteditable>
type P = (A, B, Int)
        </code></pre>
        <p>
        みたいなのは「$A$,$B$の対」とはみなせそうにありません。<br>
        「対」とそれ以外はどのように区別されるのでしょうか？
        </p>
        </section>

        <section>
        <h3> 抽象的に考えよう </h3>
        <p> $P$の具体的な内部構造に依存しない「対」の定義を考えます。 </p>
        </section>

        <section>
        <p>
        $P$が$A$,$B$の対であるならば，$P$型のデータ(以下同様)から$A$,$B$を読み出す方法があるはずです。
        </p>
        <p class="fragment">
        言い換えると$P$から$A$,$B$への特定の関数が存在します($first$と$second$と呼ぶ事にします。)。
        </p>
        <div class="fragment">
        <p>
        この様な状況を以下のように<span style="color:red">図式(diagram)</span>で表現してみます。
        </p>

        <div align="center"> <img src="fig/1/product1.png"> </div>
        </div>
        </section>

        <section>
        A,B型への関数を持つデータ型は無数に存在します。
        <div align="center"> <img src="fig/1/product2.png"> </div>
        </section>

        <section>
        <p>
        ある型からA,B型への関数は無数に存在し得ます。<br>
        データを取り出す他にも様々な計算が行えるからです。
        </p>
        <div align="center"> <img src="fig/1/product3.png"> </div>
        </section>

        <section>
        <p>
        そこで任意の型$X$と任意の関数$f: X\rightarrow A$，$g: X\rightarrow B$に対して，以下のような図式を考えます。
        </p>
        <div align="center"> <img src="fig/1/product4.png"></div>
        </section>

        <section>
        <p>
        $X$から$A$,$B$の値を作れるなら，それらの値の対を$X$から作る関数$u$が必ず存在するはずです。
        </p>
        <div align="center"> <img src="fig/1/product5.png"></div>
        </section>

        <section>
        <p>
        このとき，$u$で対を作って$first$で取り出す事は，$f$と等しく<br>
        　
        </p>
        <div align="center"> <img src="fig/1/product6.png"> </div>
        </section>

        <section>
        <p>
        $second$で取り出す事は，$g$と等しくなければいけません。<br>
        　
        </p>
        <div align="center"> <img src="fig/1/product7.png"> </div>
        </section>

        <section>
        <p>
        このことは関数合成の記号$\circ$を用いると
        </p>
        <div align="center"> $first \circ u = f \qquad second \circ u = g$ </div>
        <p>
        と表す事が出来ます。
        </p>

        <div class="fragment">
        <p>
        もしくは「以下の図式が<span style="color:red">可換(commutative)</span>である」と表現します。
        </p>
        <div align="center"> <img src="fig/1/product5.png"> </div>
        </div>
        </section>

        <section>
        <h3> $u$の唯一性 </h3>
        <p>
        $P$が$A$,$B$以外の余分なデータを持っている(対より大きい)なら，余分なデータをどう生成するかの選択肢があり
        $u$は唯一に定まりません。
        </p>
        </section>

        <section>
        <h3> 「対」の定義 </h3>
        <p>
        型$P$が型$A$,$B$の対であるという事は，<span style="color:transparent">関数$first: P\rightarrow A$，$second: P\rightarrow B$が存在し
        任意の型$X$と任意の関数$f: X\rightarrow A$, $g: X\rightarrow B$に対して，以下の図式が可換となるような
        $u: X\rightarrow P$が唯一つ存在する事である。</span>
        </p>
        <div align="center"> <img src="fig/1/product5-2.png"> </div>
        </section>

        <section>
        <h3> 「対」の定義 </h3>
        <p>
        型$P$が型$A$,$B$の対であるという事は，関数$first: P\rightarrow A$，$second: P\rightarrow B$が存在し
        <span style="color:transparent">任意の型$X$と任意の関数$f: X\rightarrow A$, $g: X\rightarrow B$に対して，以下の図式が可換となるような
        $u: X\rightarrow P$が唯一つ存在する事である。</span>
        </p>
        <div align="center"> <img src="fig/1/product5-3.png"> </div>
        </section>

        <section>
        <h3> 「対」の定義 </h3>
        <p>
        型$P$が型$A$,$B$の対であるという事は，関数$first: P\rightarrow A$，$second: P\rightarrow B$が存在し
        任意の型$X$と任意の関数$f: X\rightarrow A$, $g: X\rightarrow B$に対して，<span style="color:transparent">以下の図式が可換となるような
        $u: X\rightarrow P$が唯一つ存在する事である。</span>
        </p>
        <div align="center"> <img src="fig/1/product5-4.png"> </div>
        </section>

        <section>
        <h3> 「対」の定義 </h3>
        <p>
        型$P$が型$A$,$B$の対であるという事は，関数$first: P\rightarrow A$，$second: P\rightarrow B$が存在し
        任意の型$X$と任意の関数$f: X\rightarrow A$, $g: X\rightarrow B$に対して，以下の図式が可換となるような
        $u: X\rightarrow P$が唯一つ存在する事である。
        </p>
        <div align="center"> <img src="fig/1/product5.png"> </div>
        </section>

        <section style="color:red">
        <h3> 普遍性</h3>
        <p>
        <span style="color:lightgrey">型$P$が型$A$,$B$の対であるという事は，関数$first: P\rightarrow A$，$second: P\rightarrow B$が存在し</span>
        任意の<span style="color:lightgrey">型$X$</span>と任意の<span style="color:lightgrey">関数$f: X\rightarrow A$, $g: X\rightarrow B$</span>に対して，<span style="color:lightgrey">以下の図式が可換となるような
        $u: X\rightarrow P$</span>が唯一つ存在する事<span style="color:lightgrey">である。</span>
        </p>
        <div align="center"> <img src="fig/1/product8.png"> </div>
        </section>

        <section>
        <h3> 抽象化の力 </h3>
        </section>

        <section>
        <p>
        今の例において
        </p>

        <ul>
          <li> $P$,$A$,$B$,$X$が型であるという事 </li>
          <li> $first$, $second$, $u$, $f$, $g$が関数であるという事 </li>
          <li> $\circ$が関数合成であるという事 </li>
        </ul>

        <p>
        は本質的ではありません。
        </p>

        <p class="fragment">
        何らかの「もの」と「矢」と「矢の連結」を用いて考える事が重要です。
        </p>
        </section>

        <section>
        <h3> 「対」のアナロジー </h3>
        <p> アナロジー的に </p>
        <ul>
          <li> 「もの」をある集合$X$の部分集合 </li>
          <li> 「矢」を集合の包含関係 </li>
          <li> 「矢の連結」を包含関係の合成 </li>
        </ul>
        <p>
        とすると「対」の概念は何に対応するのかを考えてみます。
        </p>

        <p class="fragment">
        具体例として$X=\{1,2,3\}$として$\{1,2\}$と$\{1,3\}$の「対」を考えます。
        </p>
        </section>

        <section>
        <p>
        別の矢をつなげて作れる矢は省略してます。<br>
        　
        </p>
        <div align="center"> <img height="80%" src="fig/1/product9.png"> </div>
        </section>

        <section>
        <p>
        $\{1,2\}$と$\{1,3\}$に向かう矢を持つものは$\cdots$<br>
        　
        </p>
        <div align="center"> <img height="80%" src="fig/1/product10.png"> </div>
        </section>

        <section>
        <p>
        $\{1,2\}$と$\{1,3\}$に向かう矢を持つものは$\cdots$$\{1\}$と<br>
        　
        </p>
        <div align="center"> <img height="80%" src="fig/1/product11.png"> </div>
        </section>

        <section>
        <p>
        $\{1,2\}$と$\{1,3\}$に向かう矢を持つものは$\cdots$$\{1\}$と$\emptyset$<br>
        　
        </p>
        <div align="center"> <img height="80%" src="fig/1/product12.png"> </div>
        </section>

        <section>
        <p>
        $\emptyset$,$\{1\}$のそれぞれから$\{1\}$に向う矢が唯一存在して以下の図式は可換。
        </p>
        <div align="center"> <img height="80%" src="fig/1/product13.png"> </div>
        </section>

        <section>
        <p>
        つまり$\{1, 2\}$と$\{1, 3\}$の「対」に相当するものは$\{1\}$です。
        </p>
        <p class="fragment">
        実は「型と関数」の場合の「$A$,$B$の対」は、「ある集合$X$の部分集合と包含関係」の場合には<span style="color:red">「$A$,$B$の共通部分」</span>となります。
        </p>
        </section>

        <section>
        <h3> 「対」のアナロジー(その2) </h3>
        <p>
        今度は
        </p>
        <ul>
          <li> 「もの」を整数 </li>
          <li> 「矢」を「$\leqq$」 </li>
          <li> 「矢の連結」を「$\leqq$」の連結 </li>
        </ul>
        <p>
        に置き換えてみます。
        </p>

        <p class="fragment">
        具体例として$4$と$6$の「対」を考えます。
        </p>
        </section>

        <section>
        <p>
        ここでも別の矢をつなげて作れる矢は省略してます。<br>
        　
        </p>
        <div align="center"> <img src="fig/1/product14.png"> </div>
        </section>

        <section>
        <p>
        $4$,$6$の両方への矢を備えるのは$\cdots,1,2,3,4$。<br>
        このうち「対」と同じ普遍性の条件を満たすのは$4$です。
        </p>
        <div align="center"> <img src="fig/1/product15.png"> </div>
        </section>

        <section>
        <p>
        つまり$4$と$6$の「対」に相当するものは$4$です。
        </p>
        <p class="fragment">
        実は「型と関数」の場合の「$A$,$B$の対」は、「整数と順序」の場合には<span style="color:red">「$\min\{A,B\}$」</span>となります。
        </p>
        </section>

        <section>
        <h3> 素朴な定義では共通性が見えない </h3>
        <p style="height:5em; border:3px solid #999999; padding:1em">
        $A$,$B$の共通部分とは$A$,$B$の両方に含まれる要素全てからなる集合である。
        </p>
        <p style="height:5em; border:3px solid #999999; padding:1em">
            $\min\{A,B\}$とは$A$,$B$のうち小さい方である。
        </p>
        </section>

        <section>
        <h3> 言葉を変えると共通性が見えてくる </h3>
        <p style="height:5em; border:3px solid #999999; padding:1em">
        集合$A$,$B$の共通部分$P$とは$P\subseteq A$,$P\subseteq B$であって、$X\subseteq A$,$X\subseteq B$であるような任意の$X$に対して$X \subseteq P$となる集合の事である。
        </p>
        <p style="height:5em; border:3px solid #999999; padding:1em">
        整数$A$,$B$の最小値$M$とは$M\leqq A$,$M\leqq B$であって、$X\leqq A$,$X\leqq B$であるような任意の$X$に対して$X \leqq M$である整数の事である。
        </p>
        </section>

        <section>
        <p>
        一見すると無関係な3つの概念が、同じ言葉で説明出来る事を見ました。
        </p>
        <div align="center">
        <table border="3">
          <tr><td> 型と関数</td><td>・・・ </td><td> 対 </td></tr>
          <tr><td> 集合と包含関係</td><td>・・・ </td><td> 共通部分 </td></tr>
          <tr><td> 整数と順序</td><td>・・・ </td><td> 小さい方 </td></tr>
        </table>
        </div>
        <p class="fragment">
        まだ一切圏論的な定式化を行なっていませんが、これらを圏論では
        <span style="color:red">直積(product)</span>と呼びます。
        </p>
        </section>

        <section>
        <h3> 抽象化の力 </h3>
        <p>
        概念を「内的な性質」ではなく「外的な関係性」によって特徴付ける事によって
        </p>
        <ul>
          <li> 様々な概念の背後にある、本質的な構造が見えてくる。
          <li> 概念から概念への、強力なアナロジーが可能になる。
        </ul>
        <p>
        という事が解ります。
        </p>
        </section>

        <section>
        <h3> 圏の定義 </h3>
        </section>

        <section>
        <p>
        <span style="color:red">圏(category)</span>とは
        </p>
        <ul>
          <li> 対象(object):$A,B,C,\cdots$ </li>
          <li> 射(arrow,morphism):$f,g,h,\cdots$ </li>
          <li> 射の合成(composition): $\circ$ </li>
        </ul>
        <p>
        からなり、以後の条件を全て満たすものである。
        </p>
        </section>

        <section>
        <p>
        任意の射$f$には
        </p>
        <ul>
          <li> 始域(domain): $\mathrm{dom}(f)$ </li>
          <li> 終域(codomain): $\mathrm{cod}(f)$ </li>
        </ul>
        <p>
        という２つの対象が備わる。<br>
        $\mathrm{dom}(f) = A$,$\mathrm{cod}(f) = B$である事を $ f: A\rightarrow B$ と表す。
        </p>
        <div align="center"> <img src="fig/1/category1.png"> </div>
        </section>

        <section>
        <p> 射$f:A\rightarrow B$,$g:B\rightarrow C$が存在するならば、 </p>
        <ul>
          <li> 合成射(composite)　  $ g\circ f: A \rightarrow C $ </li>
        </ul>
        <p>
        も存在する。
        </p>
        <div align="center"> <img src="fig/1/category2.png"> </div>
        </section>

        <section>
        <p> 任意の射$f: A \rightarrow B$, $g: B \rightarrow C$, $h: C \rightarrow D$に対して<br> 結合律(associative law) </p>
        <div align="center"> $ (h\circ g)\circ f = h \circ (g\circ f)$ </div>
        <p> が成り立つ。すなわち、下図が可換である。</p>
        <div align="center"> <img height="55%" src="fig/1/category4.png"> </div>
        </section>

        <section>
        <p> 任意の対象$A$に対して </p>
        <ul>
          <li> 恒等射(identity)　 $ 1_A: A \rightarrow A $ </li>
        </ul>
        <p> が存在し、任意の$f: A \rightarrow B$に対して単位元律(identity law) </p>
        <div align="center"> $ f\circ 1_A = 1_B \circ f = f $ </div>
        <p> が成り立つ。すなわち、右下図が可換である。</p>
        <div align="center"> <img height="45%" src="fig/1/category3.png"> </div>
        </section>

        <section>
        <p> 端的に言うと、圏とは </p>
        <ul>
          <li> 対象の集まりと </li>
          <li> 対象から対象への者の集まりからなり </li>
          <li> 同じ対象に出入りする射と射は必ず合成でき </li>
          <li> 合成の順番は関係なく </li>
          <li> 恒等射がある </li>
        </ul>
        <p> ものです。</p>
        <p> 次回、様々な圏の例を見てみます。 </p>
        </section>

        <section>
        <h3> 先ほどの例における恒等射 </h3>
        <ul>
          <li> 集合と関数の圏: 恒等関数 $1_A(x) = x$</li>
          <li> 集合と包含関係の圏: $A \subseteq A$ </li>
          <li> 整数と順序の圏: $A \leqq A$ </li>
        </ul>
        </section>

        <section>
        <h3> 恒等射の一意性 </h3>
        <p>
        対象$A$についての恒等射を<span style="color:red">$1_A$</span>と表せるのは、
        任意の$A$について<span style="color:red">恒等射が一意に定まる</span>からです。
        </p>

        <div class="fragment">
        <p style="font-size:80%">
        <img width="40%" src="fig/1/id_is_uniq.png" align="right" hspace="20">
        【一意性の証明】<br>
        $1_A,1'_A: A\rightarrow A$が共に恒等射だとする。<br>
        恒等射の性質より右図の上半分、下半分はどちらも可換だから
        $$ 1_A = 1'_A $$
        となる。つまり恒等射は一意に定まる。<span style="float:right">□</span>
        </p>
        </div>

        <br clear="right">

        <p class="fragment">
        このような証明スタイルを<span style="color:red">diagram chasing</span>といいます。
        </p>
        </section>

        <section>
        <h2> 同型 </h2>
        </section>

        <section>
        <h3> 「等しさ」とは </h3>
        <p>
        あるものとあるものの「等しさ」というのは曖昧な概念です。<br>
        例えば集合$\{0, 1, 2\}$と$\{1, 3, 5\}$は異なりますが
        「要素の数」という観点では<span style="color:red">ある意味等しい</span>です。
        </p>
        <p class="fragment">
        圏論には「～と～がある意味等しい」という事について正確に述べる為の、様々な言葉が登場します。
        </p>
        </section>

        <section>
        <h3> 同型射 </h3>
        <p>
        $f: A\rightarrow B$に対して、$g: B\rightarrow A$が存在し、
        </p>
        <div align="center"> $ g\circ f = 1_A\qquad f\circ g = 1_B$ </div>
        <p>
        が成り立つならば$f$を<span style="color:red">同型射(isomorphism)</span>と呼ぶ。<br>
        また、圏$\mathbf{C}$において$A$と$B$の間に同型射が存在するならば、$\mathbf{C}$において$A$は$B$と<span style="color:red">同型(isomorphic)</span>であると言う。
        </p>
        <div align="center"><img src="fig/1/inverse.png"> </div>
        </section>

        <section>
        <h3> 例 </h3>
        <ul>
          <li> 対象: 集合 </li>
          <li> 射: 恒等関数のみ </li>
        </ul>
        <p>
        からなる圏では$\{0,1,2\}$と$\{1,3,5\}$は同型ではありません。
        </p>

        <div align="center"><img src="fig/1/iso_example1.png"> </div>
        <p>
        注: 同じ色の矢印を全部合わせて一つの関数(つまり射)です。
        </p>
        </section>

        <section>
        <h3> 例 </h3>
        <ul>
          <li> 対象: 集合 </li>
          <li> 射: 任意の関数 </li>
        </ul>
        <p>
        からなる圏では$\{0,1,2\}$と$\{1,3,5\}$は同型です。
        </p>

        <div align="center"><img src="fig/1/iso_example2.png"> </div>
        <p>
        注: この図にあるのは恒等射のうちの一つ(全部で6つ)です。恒等射が一つでも存在すれば同型です。
        </p>
        </section>

        <section>
        <h3> 逆射 </h3>
        <p>
        $f: A\rightarrow B$に対して
        </p>
        <div align="center"> $ g\circ f = 1_A\qquad f\circ g = 1_B$ </div>
        <p>
        となる$g$は一意に定まる。このような$g$を<span style="color:red">逆射(inverse)</span>と言い$f^{-1}$と表す。
        </p>

        <div class="fragment">
        <p style="font-size:80%">
        <img width="50%" src="fig/1/inv_is_uniq5.png" align="right" hspace="20">
        【一意性の証明】<br>
        $g, h: B\rightarrow A$が$f$の逆射であるとすると右図が可換となるから、
        $$ g = h $$
        となる。つまり逆射は一意に定まる。
        <span style="float:right">□</span>
        </p>
        </div>
        </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
        rollingLinks: false,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
      Reveal.addEventListener( 'slidechanged', function( event ) {
        MathJax.Hub.Rerender(event.currentSlide);
      });

		</script>

	</body>
</html>
