<!doctype html>
<html lang="ja">

	<head>
		<meta charset="utf-8">

    <title>圏論勉強会 第2回 @ ワークスアプリケーションズ</title>

		<meta name="description" content="Seminar of category theory">
    <meta name="author" content="Koichi Nakamura">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

    <meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />

		<!-- For syntax highlighting -->
    <link rel="stylesheet" href="plugin/highlight/styles/github.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        }
      });
    </script>
    $$ \newcommand\append{{+\hspace{-.7em}+}} $$

    <style type="text/css">
      <!--
      div.definition {
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 4px solid #333333;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
      }
      div.theorem {
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 4px solid #333333;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
      }
      div.equation {
        margin: 10px;
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 2px solid #C0C0C0;
      }
      --> 
    </style>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

        <section>
        <h1>圏論勉強会<br>第2回</h1>
        <h3>@ワークスアプリケーションズ</h3>
        <small> 中村晃一 <br> 2013年5月23日</small>
        </section>

        <section>
        <h3>謝辞</h3>
        <p>
        この勉強会の企画，会場設備の提供をして頂きました<br>
        &#12849; ワークスアプリケーションズ様<br>
        にこの場をお借りして御礼申し上げます。
        </p>
        </section>

        <section>
        <h3> この会について </h3>
        <ul>
          <li> <span style="color:red">圏論(category theory)</span>を題材にいろんなことを学びます。</li>
          <li> 分かり易さを重視して初歩的な例を多用します。</li>
          <li> 関数型言語の経験がある方がより楽しめると思います。資料中では主にHaskellを使います。 </li>
          <li> この資料は<a href="http://nineties.github.com/category-seminar/">http://nineties.github.com/category-seminar</a>に置いてあります。</li>
        </ul>
        </section>

        <section>
        <h2> 第２回:モノイド・群,それと圏論 </h2>
        </section>

        <section>
        <h3> 第2回の内容 </h3>
        <div class="fragment" align="center"> <img src="fig/pie_chart.png"> </div>
        </section>

        <section>
        <h1>モノイド勉強会</h1>
        <h3>@ワークスアプリケーションズ</h3>
        <small> 中村晃一 <br> 2013年5月23日</small>
        </section>

        <section>
        <h3> 第2回の内容 </h3>
        <p>
        今回はまず圏論を離れてモノイド・群という概念について紹介します。
        その後,様々な圏の例の紹介とモノイド・群を通して見た事実の圏論による一般化を考えます。
        </p>
        </section>

        <section>
        <h3> 用語・記法について </h3>
        <ul>
          <li> 自然数$\mathbb{N}$とは$0$以上の整数の事とします。 </li>
          <li> ２項演算子$\star$の左辺値,右辺値を定数に固定した関数を便宜的に以下の様に表す事にします。
          $$ \color{red}{(a\ \star)} : x \mapsto a \star x $$
          $$ \color{red}{(\star\ a)} : x \mapsto x \star a $$
          例えば
          $$ (2\ +)(3) = 2 + 3 \qquad (+\ 2)(3) = 3 + 2$$
          という感じです。
          </li>
        </ul>
        </section>

        <section>
        <h2> モノイド </h2>
        </section>

        <section id="monoid">
        <h3> モノイド </h3>
        <div class="definition">
        <p>
        <span style="color:red">モノイド(monoid)</span>とは集合$S$，$S$上の二項演算$\cdot$の組$(M, \cdot)$で，以下の条件を満たすものである。<br>
        </p>
        <ul>
          <li>結合律: 任意の$x,y,z \in M$について
          $$ (x\cdot y)\cdot z = x\cdot (y \cdot z)$$
          </li>
          <li> 単位元の存在: $e \in M$が存在し,任意の$x \in M$について
          $$ e\cdot x = x\cdot e = x $$
          </li>
        </ul><br>
        <p>
        $M$をこのモノイドの<span style="color:red">台集合(underlying set)</span>と言う。誤解の恐れがない場合にはモノイドと台集合に同じ記号を用いる。
        </p>
        </div>
        </section>

        <section>
        <h3> モノイド:自然数と加法 </h3>
        <p>
        $\mathbb{N}$を自然数の集合,$+$を整数の足し算としたとき,
        $$ (\mathbb{N}, +) $$
        はモノイドとなります。単位元は$0$です。
        </p>
        <p>
        モノイドの条件を全て満たす事を確認しましょう。<br>
        <div class="equation">
        <ul>
          <li> $x,y \in \mathbb{N}$ならば$x + y\in\mathbb{N}$ </li>
          <li> $(x + y) + z = x + (y + z)$ </li>
          <li> $0 + x = x + 0 = x$ </li>
        </ul>
        </div>
        </p>
        </section>

        <section>
        <h3> モノイド:自然数と乗法 </h3>
        <p>
        $\mathbb{N}$を自然数の集合,$\cdot $を整数の掛け算としたとき,
        $$ (\mathbb{N}, \cdot) $$
        はモノイドです。単位元は$1$です。
        </p>
        <div class="equation">
        <ul>
          <li> $x,y \in \mathbb{N}$ならば$x \cdot y\in\mathbb{N}$ </li>
          <li> $(x \cdot y) \cdot z = x \cdot (y \cdot z)$ </li>
          <li> $1 \cdot x = x \cdot 1 = x$ </li>
        </ul>
        </div>
        </section>

        <section>
        <h3> 加法・乗法によるモノイド </h3>
        <div align="left">
        <p> 加法については </p>
        <ul>
          <li> 整数$\mathbb{Z}$,有理数$\mathbb{Q}$,実数$\mathbb{R}$,複素数$\mathbb{C}$,$\cdots$ </li>
          <li> $2$の倍数,$3$の倍数,$\cdots$ </li>
          <li> $\{a+b\sqrt{2} | a,b\in \mathbb{Q}\}$ </li>
        </ul>
        <p> など。乗法については </p>
        <ul>
          <li> 整数$\mathbb{Z}$,有理数$\mathbb{Q}$,実数$\mathbb{R}$,複素数$\mathbb{C}$,$\cdots$ </li>
          <li> 正の自然数$\mathbb{N}^{+}$ </li>
          <li> $\{1,2,4,8,16,32,\cdots\}$ </li>
        </ul>
        <p> など、様々な集合がモノイドの条件を満たします。 </p>
        </div>
        </section>

        <section>
        <h3> モノイド:列と連結 </h3>
        <p>
        $[A]$を集合$A$を要素の有限列
        $$ [a_0, a_1,\cdots,a_n] \qquad (a_i \in A) $$
        とし,$\append$を列の結合
        $$ [a_0,\cdots,a_m]\append[b_0,\cdots,b_n] = [a_0,\cdots,a_m,b_0,\cdots,b_n] $$
        としたとき,$ ([A], \append) $はモノイドです。単位元は空列$[\,]$です。
        </p>
        <div class="equation">
        <ul>
          <li> $x,y \in [A]$ならば$x \append y\in [A]$ </li>
          <li> $(x \append y) \append z = x \append (y \append z)$ </li>
          <li> $[\,] \append x = x \append [\,] = x$ </li>
        </ul>
        </div>
        </section>

        <section>
        <h3> モノイド:文字列と連結 </h3>
        <p>
        「列」の一例として,文字列も連結に関してモノイドとなります。単位元は空文字列$\text{""}$です。
        </p>
        $$ \text{"Hello"} \append \text{" "} \append \text{"World!"} = \text{"Hello World!"} $$
        </section>

        <section>
        <h3> モノイド:論理積・論理和 </h3>
        <p> $(\{\mathrm{true},\mathrm{false}\}, \mathrm{and})$ 単位元は$\mathrm{true}$。</p>
        <div class="equation">
          $$\begin{aligned}
          &\mathrm{true}\ \mathrm{and}\ \mathrm{true}  = \mathrm{true} \\
          &\mathrm{true}\ \mathrm{and}\ \mathrm{false} = \mathrm{false}\ \mathrm{and}\ \mathrm{true} = \mathrm{false}
          \end{aligned}
          $$
        </div>
        <br>

        <p> $(\{\mathrm{true},\mathrm{false}\}, \mathrm{or})$  単位元は$\mathrm{false}$。</p>
        <div class="equation">
          $$\begin{aligned}
          & \mathrm{false}\ \mathrm{or}\ \mathrm{false}  = \mathrm{false} \\
          & \mathrm{false}\ \mathrm{or}\ \mathrm{true} = \mathrm{true}\ \mathrm{or}\ \mathrm{false} = \mathrm{true}
          \end{aligned}
          $$
        </div>
        </section>

        <section>
        <h3> モノイド:集合の$\mathrm{join}$,$\mathrm{meet}$ </h3>
        <p> $(\mathcal{P}(A), \cup)$ 単位元は$\emptyset$。</p>
        <div class="equation">
          $ X\cup\emptyset = \emptyset\cup X = X$
        </div>
        <br>

        <p> $(\mathcal{P}(A), \cap)$ 単位元は$A$。 </p>
        <div class="equation">
          $ X\cap A = A\cap X = X \quad (X\subseteq A) $
        </div>
        </ul>
        <p style="font-size:80%">
        $\mathcal{P}(A)$は$A$の部分集合全てからなる集合($A$のべき集合)です。例えば
        $$ \mathcal{P}(\{1,2,3\}) = \{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{2,3\},\{1,3\},\{1,2,3\}\}$$
        のような集合です。
        </p>
        </section>

        <section>
        <h3> モノイド:最大値・最小値</h3>
        <p> $A$を最小値$m$を持つ数値の集合とすると,$(A, \max)$は$m$を単位元とするモノイドです。</p>
        <div class="equation">
          $\max\{m, x\} = \max\{x, m\} = x \quad (x \in A) $
        </div>
        <br>
        <p> $A$を最大値$m$を持つ数値の集合とすると,$(A, \min)$は$M$を単位元とするモノイドです。</p>
        <div class="equation">
          $\min\{M, x\} = \min\{x, M\} = x \quad (x \in A) $
        </div>
        </section>

        <section>
        <p>
        今の３つの例は「有界半束はモノイドである」という事実の具体例です。
        「束」については後の回に説明しますので,本日は分からなくても大丈夫です。
        </p>
        </section>

        <section>
        <h3> プログラミングにおけるモノイド </h3>
        </section>

        <section>
        <h3> 集約演算 </h3>
        <p> データ列に対する集約・集積演算はモノイドと関係します。 </p>
        <ul>
          <li> 値の和・積を求める。 </li>
          <li> 条件を満たす要素を集める。 </li>
          <li> 最大値・最小値を計算する。 </li>
          <li> 全て～であるか？～を満たす物があるか？ </li>
        </ul>
        <p> 関数型言語では<span style="color:red">畳み込み(folding)</span>と呼ぶ事が多いです。</p>
        </section>

        <section>
        <p> 格納データを<span style="color:red">直列化</span>出来るコンテナに対して,モノイドによる畳込みを定義する事が出来ます。</p>
        <div align="center"> <img height="70%" src="fig/fold1.png"> </div>
        </section>

        <section>
        <p> モノイドの結合性は任意の部分列から畳み込む事を正当化しますので,効率のよいアルゴリズムを考える際に重要です。 </p>
        <div align="center"> <img height="70%" src="fig/fold2.png"> </div>
        </section>

        <section>
        <p> 都合良くモノイドな値を格納している事は少ないので,個々の値を適当なモノイドにマッピングする操作とセットで考えましょう。 </p>
        <div align="center"> <img height="70%" src="fig/fold3.png"> </div>
        </section>

        <section>
        <p> つまり,$\mathrm{map}$と$\mathrm{fold}$を合成した関数によって様々な畳み込みを行うことがはずです。 </p>
        <div align="center"> <img height="70%" src="fig/fold4.png"> </div>
        </section>

        <section>
        <h3> Haskellでの例 </h3>
        <pre><code data-trim class="haskell" contenteditable>
-- 当日Haskellでいくつか例をお見せします。
-- 使用したコードは後でここに反映させます。











        </code></pre>
        </section>

        <section>
        <h3> とても便利ですね～</h3>
        <p class="fragment">
        冷静に考えるとまだよく分からない。
        <ul>
          <li class="fragment"> 足すとか掛けるとか,一種類の計算しか出来ないのか？ </li>
          <li class="fragment"> 何が出来て何が出来ないのか? </li>
        </ul>
        </p>
        </section>

        <section>
        <h3> 例えば絵を描くという作業 </h3>
        <img width="45%" src="fig/monoid_endofunction_example.png" align="right" hspace="20">
        <ul>
          <ol> 円を描いて </ol>
          <ol> 線を引いて </ol>
          <ol> 色を塗って </ol>
          <ol> ･･･ </ol>
        </ul><br clear="right">
        <p> 絵とは一連の作業の<span style="color:red">集積結果</span>では？ </p>
        </section>

        <section>
        <h3> 例えばロボットの操作 </h3>
        <img width="45%" src="fig/monoid_endofunction_example2.png" align="right" hspace="20">
        <ul>
          <ol> 右を向け </ol>
          <ol> 前へ進め </ol>
          <ol> 止まれ </ol>
          <ol> ・・・ </ol>
        </ul><br clear="right">
        <p> ロボットの動きとは一連の命令の<span style="color:red">集積</span>では？ </p>
        </section>

        <section>
        <h3> モノイド: endomorphism </h3>
        <img width="30%" src="fig/endomorphism.png" align="right" hspace="20">
        <p style="font-size:90%">
        ドメインとコドメインが同じ集合である関数を,<span style="color:red">自己準同型(endomorphism)</span>と言います。
        </p>
        <div class="fragment">
        <p style="font-size:90%">
        集合$A$上の自己準同型全ての集合を$\color{red}{\mathrm{End}(A)}$と表す事にすると,
        $$ \left(\mathrm{End}(A),\circ\right) $$
        は恒等関数$\mathrm{id}_A$を単位元とするモノイドです。これを同じく
        $\mathrm{End}(A)$と表すことにします。
        </p><br clear="right">
        <div class="equation">
          $$ \begin{aligned}
          & h\circ(g\circ f) = (h\circ g)\circ f \\
          & \mathrm{id}_A\circ f = f\circ \mathrm{id}_A = f
          \end{aligned}$$
        </div>
        </div>

        <div align="left" style="font-size:50%">
          注: 集合は全く構造のない代数系と見なせるので,後の事も考えて準同型と呼ぶことにします。
        </div>
        </section>

        <section>
        <h3> Haskellでの例 </h3>
        <pre><code data-trim class="haskell" contenteditable>
-- 当日Haskellでいくつか例をお見せします。
-- 使用したコードは後でここに反映させます。











        </code></pre>
        </section>

        <section>
        <h3> モノイドの表現 </h3>
        </section>

        <section>
        <p style="font-size:150%">
        もしかして,任意のモノイドは台集合上の自己準同型によって表せるのでは？
        </p>
        <div class="fragment" align="center"> <img src="fig/monoid_cayley.png"> </div>
        </section>

        <section>
        <p> いくつか言葉を準備して,この現象について考えてみます。 </p>
        <div align="center"> <img src="fig/monoid_cayley2.png"> </div>
        </section>

        <section>
        <h3> 準備: モノイド準同型 </h3>
        <p>
        モノイドからモノイドへの構造を保ったマッピングを(モノイドの)<span style="color:red">準同型(homomorphism)</span>と言います。モノイドの構造とは結合的な２項演算と単位元の事でした。
        </p>
        <div class="fragment">
        <div class="definition">
          <p>
          モノイド$(M,\star)$から$(N,\diamond)$への準同型$F: (M,\star) \rightarrow (N,\diamond)$とは,$M$から$N$への関数であり以下の条件を満たすもの。<br>
          <ul>
            <li> $ F(x\star y) = F(x)\diamond F(y)$ </li>
            <li> $ F(e_{\star}) = e_{\diamond}\quad(\text{$e_{\star}$,$e_{\diamond}$は各モノイドの単位元}) $ </li>
          </ul>
          </p>
        </div>
        </div>
        </section>

        <section>
        <h3> 準同型の例: $\mathrm{length}$ </h3>
        <p>
        有限列の長さを得る関数$\mathrm{length}$は準同型
        $$ \mathrm{length} : ([A],\append) \rightarrow (\mathbb{N},+) $$
        と見なせます。
        <br>
        <div class="equation">
        $$ \begin{aligned}
        &\mathrm{length}([a_0,\cdots,a_m]\append[b_0,\cdots,b_n]) \\
        &\quad = \mathrm{length}([a_0,\cdots,a_m]) + \mathrm{length}([b_0,\cdots,b_n]) \\
        &\mathrm{length}([\ ]) = 0
        \end{aligned} $$
        </div>
        </p>
        </section>

        <section>
        <h3> 準備: モノイドの同型 </h3>
        <p> 同型とは２つのモノイドが「本質的に同じものである」という性質です。</p>
        <div class="definition">
          <p>
          全単射(全体をカバーする一対一対応)である準同型を<span style="color:red">同型写像(isomorphism)</span>と言う。モノイド$M$と$N$の間に同型写像が存在する時,$M$と$N$は<span style="color:red">同型(isomorphic)</span>であると言い
          $$ M \cong N $$
          と表す。
          </p>
        </div>
        </section>

        <section>
        <h3> 同型の例: $x \mapsto a^x$ </h3>
        <p>
        例えば$f(x) = 2^x$という関数は準同型
        $$ f: (\mathbb{N},+) \rightarrow (\{1,2,4,8,16,\cdots\},\cdot) $$
        と見なせます。
        </p>
        <div class="equation">
        $$ 2^{x+y} = 2^x\cdot 2^y \qquad 2^0 = 1 $$
        </div>
        <p>
        さらにこれは全単射なので同型を与えます。
        $$ (\mathbb{N},+) \cong (\{1,2,4,8,16,\cdots\},\cdot) $$
        </p>
        </section>

        <section>
        <h3> 準備: 部分モノイド </h3>
        <div class="definition">
          <p>
        同じ演算からなるモノイド$(A, \cdot)$と$(B,\cdot)$について,$A \subseteq B$であるならば$A$は$B$の<span style="color:red">部分モノイド</span>であると言い
        $$ (A,\cdot) \subseteq (B,\cdot) $$
        と表す。
        </p>
        </div>
        <p>
        例えば,下のような例があります。
        $$(\{0,2,4,6,8,\cdots\},+) \subseteq (\mathbb{N}, +) \subseteq (\mathbb{Z}, +) $$
        </p>
        </section>

        <section>
        <h3> 定理 </h3>
        <div class="theorem">
        <p>
        任意のモノイド$(M, \cdot)$は$\mathrm{End}(M)$の適当な部分モノイドと同型である。
        </p>
        </div>
        </section>

        <section>
        <div align="left" style="font-size:80%">
        【証明】<br>
        <span class="fragment">モノイド$M=(\{a,b,\cdots\},\cdot)$に対して,$\overline{M} = \{(a\ \ \cdot),(b\ \ \cdot),\cdots\}$とする。$e\in M$を単位元とする。</span><span class="fragment">すると,任意の$a,b\in M$に対して</span>
        <ul>
          <li class="fragment"> 任意の$x\in M$について$((a\cdot b)\ \ \cdot)(x) = (a\ \ \cdot)\circ(b\ \ \cdot)(x) = a\cdot b\cdot x$ なので
          $$ ((a\cdot b)\ \ \cdot) = (a\ \ \cdot)\circ(b\ \ \cdot) $$
          </li>
          <li class="fragment"> 任意の$x\in M$について$(e\ \ \cdot)(x) = e\cdot x = x$なので
          $$ (e\ \ \cdot) = \mathrm{id}_{M} $$
          </li>
        </ul>
        <p class="fragment">
        すなわち$\phi: a\mapsto (a\ \ \cdot)$は$M$から$\overline{M}\subseteq\mathrm{End}(M)$への準同型を定める。
        </p>
        </div>
        </section>

        <section>
        <p> ここで$\overline{M}$から$M$への写像$\psi: f\mapsto f(e)$を考えると,</p>
        <ul>
          <li class="fragment"> 任意の$x \in M$について
          $$ \psi\circ \phi(x) = \psi((x\ \ \cdot)) = (x\ \ \cdot)(e) = x\cdot e = x$$
          </li>
          <li class="fragment"> 任意の$(x\ \ \cdot) \in \overline{M}$について
          $$ \phi\circ\psi(f) = \phi((x\ \ \cdot)(e)) = \phi(x) = (x\ \ \cdot)$$
          </li>
        </ul>
        <p class="fragment">
        すなわち
        $$ \psi\circ\phi = \mathrm{id}_{M}\qquad\phi\circ\psi = \mathrm{id}_{\overline{M}}$$
        となるから$\phi$は全単射である。
        </p>
        <p class="fragment"> 従って$(M, \cdot) \cong (\overline{M}, \circ)$ <span style="float:right">□</span> </p>
        </section>

        <section>
        <p> 同様に$a\mapsto (\cdot\ \ a)$という同型写像を考える事も出来ます。ただし,畳み込みの順番を保つ為には関数合成の順番を逆にしたモノイド($\mathrm{End}(A)$の反モノイドと言います。)への写像を考える必要があります。
        </p>
        <div align="center"> <img src="fig/opposite_monoid_cayley.png"> </div>
        </section>

        <section>
        <h2> $\mathrm{foldr}と\mathrm{foldl}$ </h2>
        </section>

        <section>
        <p>
        関数型言語を勉強するとそのうち$\color{red}{\mathrm{foldr}}$,$\color{red}{\mathrm{foldl}}$という謎の関数に出くわします。この授業でも今後よく登場すると思います。
        </p>
        <p class="fragment">
        さて,名前から分かる様にこれも畳み込みを行う関数ですのでモノイドと関係があるはずです。
        今回はそのような視点からこれらを眺めてみます。
        </p>
        </section>

        <section>
        <h3> $\mathrm{foldr},\,\mathrm{foldl}$とは</h3>
        <p>
        $\mathrm{foldr}$は二項演算$\star : A\times B\rightarrow B$,$x \in B$を受け取り,$A$の要素の列$[A]$を以下のように$B$の値に畳み込みます。
        </p>
        <p>
        同様に$\mathrm{foldl}$は二項演算$\diamond : B\times A\rightarrow B$,$x \in B$を受け取り,以下のように畳み込みます。
        </p>
        <div align="center"> <img src="fig/foldr_foldl.png"> </div>
        </section>

        <section>
        <p> ちょっと書きなおすと・・・</p>
        <div class="fragment" align="center"> <img src="fig/foldr_foldl2.png"> </div>
        <p class="fragment">
        つまり$\mathrm{foldr},\,\mathrm{foldl}$は、自己準同型へのマッピングと値の代入を一挙に行なってくれる関数という見方が出来ます。
        </p>
        <p class="fragment">
        全てのモノイドは自己準同型のなすモノイドとして表現出来るので,$\mathrm{foldMap}$で出来る事は全て$\mathrm{foldr},\,\mathrm{foldl}$でも出来るという事になります。
        </p>
        <p class="fragment">
        さらに$\star$,$\diamond$は<span style="color:red">モノイドの演算でなくても良い</span>のでより汎用性が高いのです。
        </p>
        </section>

        <section>
        <h3> Haskellでの例 </h3>
        <pre><code data-trim class="haskell" contenteditable>
-- 当日Haskellでいくつか例をお見せします。
-- 使用したコードは後でここに反映させます。











        </code></pre>
        </section>

        <section>
        <h3> 自由モノイド </h3>
        </section>

        <section>
        <p>
        $\mathrm{foldMap}\ f$という関数は列の各要素を$f$でマッピングしてから畳み込む関数でした。
        </p>
        <div align="center"> <img src="fig/foldMap_homomorphism.png"> </div>
        <p class="fragment">
        ところで連結演算によて<span style="color:red">列自体もモノイド</span>となります。すると$\mathrm{foldMap}\ f$はモノイド準同型となります。
        </p>
        </section>

        <section>
        <h3> 自由モノイド </h3>
        <p>
        「畳込み」を「列に縮約演算を入れる事」だと思えば,全ての畳み込みが「列と連結」からのモノイド準同型として作れる事になります。つまり,「列と連結」は特別なモノイドです。
        </p>
        <p class="fragment">
        この事を$([A], \append)$は$A$上の<span style="color:red">自由モノイド(free monoid)</span>であると言います。
        </p>
        </section>

        <section>
        <h3> 抽象的な自由モノイドの定義が欲しい! </h3>
        <p>
        「列と連結」という自由モノイドの定義は非常に具体的です。<br>
        「もの」と「矢印」と「矢印の連結」よって定義を与える事が出来れば,後に圏論に進んだ際にモノイド以外の概念に応用できるはずです。
        </p>
        </section>

        <section>
        <h3> 自由モノイドの本質とは </h3>
        <p>
        任意の空でない列は下図のように長さ$1$の列に分解出来ます。一切の縮約演算が行われていないから,このような分解が出来るわけです。
        </p>
        <p>
        すると,自由モノイドからの準同型は「列の個々の要素のマッピング」のみによって完全に決定されます。
        </p>
        <div align="center"> <img src="fig/free_monoid2.png"> </div>
        </section>

        <section>
        <p> これがまさに$\mathrm{foldMap}$という関数が行なっている事です。</p>
        </p>
        <div align="center"> <img src="fig/free_monoid1.png"> </div>
        </section>

        <section>
        <p>
        集合$A$の要素を長さ$1$の列にする関数を$i$とすると,下の図式が長さ$1$の列に対する$\mathrm{foldMap}\ f$の効果を定めます。この図式によって$\mathrm{foldMap}\ f$が完全に決定されるというのが,自由モノイドの性質なのです。
        </p>
        <div align="center"> <img height="30%" src="fig/free_monoid3.png"> </div>
        </section>

        <section id="free_monoid">
        <h3> 自由モノイドの定義 </h3>
        <div class="definition">
        <p>
        モノイド$F(A)$が集合$A$上の自由モノイドであるとはそれがある関数$i: A\rightarrow F(A)$を備えており,任意の関数$f: A\rightarrow M$に対して下側の図式が可換となるようなモノイド準同型$\overline{f}: F(A)\rightarrow M$が唯一つ存在することである。
        </p>
        <div align="center"> <img src="fig/free_monoid4.png"> </div>
        </div>
        <div align="left" style="font-size:50%">
          注: モノイドと台集合,準同型と台集合間の関数に同じ記号を使っています。記号の使い分けは圏論に入ってからにします。
        </div>
        </section>

        <section>
        <h3> 最後に </h3>
        </section>

        <section>
        <h3> モノイド: プログラム </h3>
        <p>
        プログラムを「文(statement)の列」と思うと,「何もしない文」を単位元とし「文を並べる事」を演算とするモノイドと見なせます。
        </p>
        <div align="center"><img height="50%" src="fig/monoid_program.png"></div>
        </section>

        <section>
        <div align="left" style="font-size:150%">
          モナドは(ry
        </div>
        </section>

        <section>
        <h2> 定義の復習 </h2>
        </section>

        <section id="category">
        <h3> 圏 </h3>
        <div class="definition">
        <p>
        <span style="color:red">圏(category)</span>とは
        </p>
        <ul>
          <li> 対象(object):$A,B,C,\cdots$ </li>
          <li> 射(arrow,morphism):$f,g,h,\cdots$ </li>
          <li> 射の合成(composition): $\circ$ </li>
        </ul>
        <p>
        からなり,以後の条件を全て満たすものである。
        </p>
        </div>
        </section>

        <section>
        <div class="definition">
        <p>
        任意の射$f$には
        </p>
        <ul>
          <li> ドメイン(domain): $\mathrm{dom}(f)$ </li>
          <li> コドメイン(codomain): $\mathrm{cod}(f)$ </li>
        </ul>
        <p>
        という２つの対象が備わる。<br>
        $\mathrm{dom}(f) = A$,$\mathrm{cod}(f) = B$である事を $ f: A\rightarrow B$ と表す。
        </p>
        <div align="center"> <img src="fig/category1.png"> </div>
        </div>
        </section>

        <section>
        <div class="definition">
        <p> 射$f:A\rightarrow B$,$g:B\rightarrow C$が存在するならば, </p>
        <ul>
          <li> 合成射(composite)  $ g\circ f: A \rightarrow C $ </li>
        </ul>
        <p>
        も存在する。
        </p>
        <div align="center"> <img src="fig/category2.png"> </div>
        </div>
        </section>

        <section>
        <div class="definition">
        <p> 任意の射$f: A \rightarrow B$, $g: B \rightarrow C$, $h: C \rightarrow D$に対して 結合律(associative law) </p>
        <div align="center"> $ (h\circ g)\circ f = h \circ (g\circ f)$ </div>
        <p> が成り立つ。すなわち,下図が可換である。</p>
        <div align="center"> <img height="55%" src="fig/category4.png"> </div>
        </div>
        </section>

        <section>
        <div class="definition">
        <p> 任意の対象$A$に対して </p>
        <ul>
          <li> 恒等射(identity) $ 1_A: A \rightarrow A $ </li>
        </ul>
        <p> が存在し,任意の$f: A \rightarrow B$に対して単位元律(<span style="font-size:80%">identity law</span>) </p>
        <div align="center"> $ f\circ 1_A = 1_B \circ f = f $ </div>
        <p> が成り立つ。すなわち,右下図が可換である。</p>
        <p> また,恒等射は一意に定まる(証明は第1回)。 </p>
        <div align="center"> <img height="45%" src="fig/category3.png"> </div>
        </div>
        </section>

        <section id="isomorphism">
        <h3> 同型 </h3>
        <div class="definition">
        <p>
        $f: A\rightarrow B$に対して,$g: B\rightarrow A$が存在し,
        </p>
        <div align="center"> $ g\circ f = 1_A\qquad f\circ g = 1_B$ </div>
        <p>
        が成り立つならば$f$を<span style="color:red">同型射(isomorphism)</span>と呼ぶ。<br>
        また,圏$\mathbf{C}$において$A$と$B$の間に同型射が存在するならば,$\mathbf{C}$において$A$は$B$と<span style="color:red">同型(isomorphic)</span>であると言い,
        $$ A \cong B$$
        と表す。
        </p>
        <div align="center"><img src="fig/inverse.png"> </div>
        </div>
        </section>

        <section id="inverse">
        <h3> 逆射 </h3>
        <div class="definition">
        <p>
        $f: A\rightarrow B$が同型射ならば
        </p>
        <div align="center"> $ g\circ f = 1_A\qquad f\circ g = 1_B$ </div>
        <p>
        となる$g$は一意に定まる(証明は第1回)。
        このような$g$を<span style="color:red">逆射(inverse)</span>と言い$f^{-1}$と表す。
        </p>
        </div>
        </section>

        <section id="functor">
        <h3> 函手 </h3>
        <div class="definition">
        <p> 圏$\mathbf{C}$から圏$\mathbf{D}$への函手$F: \mathbf{C}\rightarrow\mathbf{D}$とは
        $\mathbf{C}$の各対象$A$に$\mathbf{D}$の対象$F(A)$を対応付け,
        $\mathbf{C}$の各射$f: A\rightarrow B$に$\mathbf{D}$の射$ F(f): F(A) \rightarrow F(B) $を
        対応付ける2つの関数の組であり,以下の条件を満たすものである。 </p>
        <div align="left">
        <ul>
          <li> 任意の$\mathbf{C}$の射$f: A\rightarrow B$, $g: B\rightarrow C$に対して
          $$ F(g\circ f) = F(g) \circ F(f) $$
          </li>
          <li> 任意の$\mathbf{C}$の対象$A$に対して
          $$ F(1_A) = 1_{F(A)} $$
          </li>
        </ul>
        </div>
        <p>
        函手は図式の可換性を保つので,それによって定義される逆射・同型性を保つ。
          $$ F(f^{-1}) = F(f)^{-1} \qquad A\cong B \Rightarrow F(A) \cong F(B)$$
        </p>
        </div>
        </section>

        <section>
        <h2> 様々な圏 </h2>
        </section>

        <section>
        <h3> $\mathbf{Sets}$ </h3>
        </section>

        <section>
        <h3> $\mathbf{1}$ </h3>
        <p>
        対象が1つ、射が恒等射のみの圏を<span style="color:red">$\mathbf{1}$</span>と表します。恒等射は必ず存在するので，図中では省略します。
        </p>
        <div align="center"><img height="50%" src="fig/category-1.png"> </div>
        </section>

        <section>
        <h3> $\mathbf{2}$ </h2>
        <p>
        対象が２つ，恒等射以外の射が下図のように1つだけ圏を<span style="color:red">$\mathbf{2}$</span>と表します。
        </p>
        <div align="center"><img height="50%" src="fig/category-2.png"> </div>
        </section>

        <section>
        <h3> $\mathbf{3}$ </h2>
        <p>
        対象が３つ，恒等射以外の射が下図のように3つだけの圏を<span style="color:red">$\mathbf{3}$</span>と表します。もちろん，斜めの射は他の２つの射の合成です。
        </p>
        <div align="center"><img height="50%" src="fig/category-3.png"> </div>
        </section>

        <section>
        <h3> 何の役に立つのか？ </h3>
        <p class="fragment">
        これらの圏それ自体はつまらないですが，これらの圏から任意の圏$\mathbf{C}$への函手が面白いです。
        </p>
        <div class="fragment" align="center"><img height="60%" src="fig/functor_from_123.png"> </div>
        </section>

        <section>
        <p>
        つまり，以下の事が言えます。
        </p>
        <ul>
          <li> $\mathbf{1}$から$\mathbf{C}$への函手は，$\mathbf{C}$の対象と一対一に対応。 </li>
          <li> $\mathbf{2}$から$\mathbf{C}$への函手は，$\mathbf{C}$の射と一対一に対応。 </li>
          <li> $\mathbf{3}$から$\mathbf{C}$への函手は，$\mathbf{C}$の合成可能な射の対と一対一に対応。 </li>
        </ul>
        <p class="fragment">
        このように<span style="color:red">函手と対象や射を同一視できる</span>という視点を持つ事はとても重要です。
        </p>
        </section>

        <section>
        <h3> 空圏 </h3>
        <p>
        対象も射も無い圏を<span style="color:red">空圏(empty category)</span>と言って<span style="color:red">$\mathbf{0}$</span>と表します。
        以下の事が言えます。<br>
        <ul>
          <li> 空圏から任意の圏$\mathbf{C}$へ函手が唯一つ存在する。</li>
          <li> 圏$\mathbf{C}$が空圏でないなら，$\mathbf{C}$から空圏への函手は存在しない。(対象・射の移り先が無い)</li>
        </ul>
        </p>
        <div align="center"><img height="40%" src="fig/category-0.png"> </div>
        </section>

        <section>
        <h3> 空関数 </h3>
        <p>
        <span style="color:red">空集合$\emptyset$から任意の集合への関数は唯一</span>です。この唯一の関数を<span style="color:red">空関数</span>と呼びます。
        空圏から任意の圏への函手が唯一つである事はこの事実から言えます。今後の為に覚えておきましょう。
        </p>
        <p class="fragment" style="font-size:80%">
        【説明】<br>
        集合$A$から$B$への関数は$A$,$B$の要素の対からなる集合$F$で，
        「任意の$x \in A$に対して$(x, y) \in F$となる$y\in B$が唯一つ存在する(※)」
        という条件を満たすもの(グラフと呼ぶ)によって定まります。$A = \emptyset$の場合には$A$の要素など存在しないのですから，
        $F = \emptyset$である事が必要で，さらに(※)は前提が偽なので真となります。したがってグラフが$\emptyset$しかないのですから対応する関数も唯一つとなります。
        </p>
        </section>

        <section>
        <h3> 離散圏 </h3>
        <p>
        全ての射が恒等射である圏を<span style="color:red">離散圏(discrete category)</span>と言います。
        離散圏は対象の集合から一意に作れます。
        </p>
        <p class="fragment">
        つまり，<span style="color:red">離散圏とは集合</span>です。
        </p>
        <div align="center"><img height="50%" src="fig/discrete_category.png"> </div>
        </section>

        <section>
        <h3> モノイド </h3>
        <p>
        対象が1つである圏を<span style="color:red">モノイド(monoid)</span>と言います。<br>
        プログラミングの様々な場面で現れる重要な構造です。
        </p>
        <p class="fragment">
        「対象が1つ」$\Leftrightarrow$「全ての射が互いに合成可能」という事が重要で<span style="color:red">その対象が何なのかはどうでも良い</span>事が多いです。
        </p>
        <div align="center"><img height="50%" src="fig/monoid.png"> </div>
        </section>

        <section>
        <p>
        というように紹介しましたが,モノイド1つだけを考える際に圏論を持ち出すのはあまり意味がありません。
        圏としてではない一般的な定義を次に説明します。
        </p>
        </section>

        <section id="monoid">
        <h3> モノイド </h3>
        <p>
        モノイドとは集合$S$，$S$上の二項演算$\cdot$の組<span style="color:red">$(S, \cdot)$</span>で，以下の条件を満たすものである。<br>
        <ul>
          <li>結合律: 任意の$x,y,z \in S$について
          $$ (x\cdot y)\cdot z = x\cdot (y \cdot z)$$
          </li>
          <li> 単位元の存在: ある$e \in S$が存在し,任意の$x \in S$について
          $$ e\cdot x = x\cdot e = x $$
          </li>
        </ul>
        </p>
        <p class="fragment">
        圏として解釈すると，$M$が射の集合,$\cdot$が射の合成,$e$が恒等射に対応します。
        </p>
        </section>

        <section>
        <h3> 加法によるモノイド </h3>
        <p>
        $0$を含んでいて加法について閉じていればモノイドなので,他にも以下のような例があります。
        <ul>
        </ul>
        </p>
        </section>

        <section>
        <h3> モノイドの例:自然数と加法 </h3>
        <p>
        $\mathbb{N}$を$0$以上の自然数の集合,$+$を自然数の足し算としたとき,
        $$ (\mathbb{N}, +) $$
        はモノイドとなります。単位元は$0$です。
        </p>
        <div class="fragment">
        <p>
        <img align="right" height="50%" src="fig/monoid_nat_add.png">
        圏として描くと下図のように<span style="color:red">$\{0,1,2,3\cdots\}$が射</span>になります。
        (★は全部同じ対象です。)
        </p>
        </div>
        </section>

        <section>
        <h3> モノイドの例:加法・乗法によるモノイド </h3>
        <ul>
          <li> $(\mathbb{Z}, +),\quad(\mathbb{Q},+),\quad(\mathbb{R},+),\quad(\mathbb{C},+)$ </li>
          <li> $(\{0,2,4,8,\cdots\}, +),\quad(\{0,3,6,9,\cdots\}, +)$ </li>
          <li> $(\{\cdots,-10,-5,0,5,10,\cdots\},+)$ </li>
          <li> $(\{a+b\sqrt{2}|a,b\in \mathbb{Z}\}, +)$ </li>
          <li> $(\mathbb{Z}, \cdot),\quad(\mathbb{Q},\cdot),\quad(\mathbb{R},\cdot),\quad(\mathbb{C},\cdot)$ </li>
          <li> $(\{1,2,4,8,16,\cdots\},\cdot),\quad(\{1,3,9,27,\cdots\},\cdot)$ </li>
          <li> $(\{2^a3^b|a,b\in\mathbb{N}\},\cdot)$ </li>
          <li> $(\{1,-1,i,-i\}, \cdot)$ </li>
        </ul>
        $\vdots$
        </section>

        <section>
        <h3> モノイドの例:文字列と連結</h3>
        <p>
        文字列と文字列の連結
        $$ ({\tt String}, ++) $$
        はモノイドとなります。単位元は空文字列$\tt{""}$です。
        </p>
        <div align="center"><img height="50%" src="fig/monoid_string_append.png"></div>
        </section>

        <section>
        <h3> モノイドの例:リストと連結 </h3>
        <p>
        リスト型とリストの連結
        $$ ([A], ++) $$
        はモノイドとなります。単位元は空リスト$[\,]$です。
        </p>
        <div align="center"><img height="50%" src="fig/monoid_list_append.png"></div>
        </section>

        <section>
        <h3> その他のモノイド </h3>
        <p>
        <ul> 
          <li> 論理積: $(\{\mathrm{true},\mathrm{false}\}, \mathrm{and})$ </li>
          <li> 論理和: $(\{\mathrm{true},\mathrm{false}\}, \mathrm{or})$ </li>
          <li> 集合のjoin: $(\mathcal{P}(A), \cup)$ </li>
          <li> 集合のmeet: $(\mathcal{P}(A), \cap)$ </li>
          <li> 最大値: $(\{0,1,2,\cdots,n\},\max)$ </li>
          <li> 最小値: $(\{0,1,2,\cdots,n\},\min)$ </li>
        </ul>
        </p>
        <p style="font-size:80%">
        $\mathcal{P}(A)$は$A$の部分集合全てからなる集合($A$のべき集合)です。例えば
        $$ \mathcal{P}(\{1,2,3\}) = \{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{2,3\},\{1,3\},\{1,2,3\}\}$$
        となります。
        </p>
        </section>

        <section>
        <h3> プログラミングでのモノイド </h3>
        <p>
        値の列を<span style="color:red">畳み込む</span>操作の多くはモノイド演算として抽象化できます。
        </p>
        <div align="center"><img height="50%" src="fig/folding.png"></div>
        </section>

        <section>
        <h3> プログラミングでのモノイド </h3>
        <p>
        GHC(Haskellの処理系)の<code>foldMap</code>という関数を使う例です。<span style="color:red">具体的な処理内容を書かなくても</span>,値をモノイド型にマッピングするだけで様々な畳み込みが出来ます。
        </p>
        <pre><code data-trim class="haskell" contenteditable>
-- 当日Haskellでいくつか例を動かします。
-- 使用したコードは後でここに反映させます。
        </code></pre>
        </section>

        <section>
        <div align="center"> <img src="fig/monoid_endofunction_example.png"> </div>
        </section>

        <section id="monoid-homomorphism">
        <h3> モノイド準同型(monoid homomorphism) </h3>
        <p>
        モノイド間の構造を保つマッピングを<span style="color:red">モノイド準同型(monoid homomorphism)</span>と言います。
        </p>
        <div style="border:1px solid #C0C0C0;padding:5px 5px 5px 5px">
        <p>
        モノイド$M=(|M|,\circ_M)$から$N=(|N|,\circ_N)$への準同型$F: M\rightarrow N$とは,関数$f: |M|\rightarrow |N|$で,以下の条件を満たすもの。<br>
        <ul>
          <li> $ f(x\circ_M y) = f(x)\circ_N f(y) $ </li>
          <li> $ f(e_M) = e_N \qquad (\text{$e_M$,$e_N$は$M$,$N$の単位元}) $ </li>
        </ul>
        </p>
        </div>
        <p class="fragment">
        モノイドを圏とみなした場合は,準同型とは関手の事です。
        </p>
        </section>

        <section>
        もしかして全部endofunctionであらわせるんじゃね？
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
        rollingLinks: false,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
      Reveal.addEventListener( 'slidechanged', function( event ) {
        MathJax.Hub.Rerender(event.currentSlide);
      });

		</script>

	</body>
</html>
