<!doctype html>
<html lang="ja">

	<head>
		<meta charset="utf-8">

    <title>圏論勉強会 第2回 @ ワークスアプリケーションズ</title>

		<meta name="description" content="Seminar of category theory">
    <meta name="author" content="Koichi Nakamura">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

    <meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />

		<!-- For syntax highlighting -->
    <link rel="stylesheet" href="plugin/highlight/styles/github.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        }
      });
    </script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

        <section>
        <h1>圏論勉強会<br>第2回</h1>
        <h3>@ワークスアプリケーションズ</h3>
        <small> 中村晃一 <br> 2013年5月16日</small>
        </section>

        <section>
        <h3>謝辞</h3>
        <p>
        この勉強会の企画，会場設備の提供をして頂きました<br>
        &#12849; ワークスアプリケーションズ様<br>
        にこの場をお借りして御礼申し上げます。
        </p>
        </section>

        <section>
        <h3> この会について </h3>
        <ul>
          <li> <span style="color:red">圏論(category theory)</span>を題材にいろんなことを学びます。</li>
          <li> 計算機科学関係の話題が多めになると思います。分かり易さを重視して初歩的な例を多用します。</li>
          <li> 毎週1回，全12週くらいの予定です。</li>
          <li> 何らかの関数型言語に触れていた方が今後の授業をより楽しめると思います。資料中ではHaskellを使う事が多いです。</li>
          <li> 他の聴衆の為にもなるので,質問・コメントを歓迎します。</li>
          <li> この資料は<a href="http://github.com/nineties/category-seminar">http://github.com/nineties/category-seminar</a>に置いてあります。</li>
        </ul>
        </section>

        <section>
        <h2> 第２回:圏と函手</h2>
        </section>

        <section>
        <h3> 第2回の内容 </h3>
        <p>
        <ul>
          <li> 圏・函手の定義 </li>
          <li> 圏・函手の具体例 </li>
          <li> 圏の構成方法 </li>
        </ul><br>
        などを学びます。
        </p>
        </section>

        <section>
        <h2> 定義の復習 </h2>
        </section>

        <section>
        <h3> 圏の定義 </h3>
        <p>
        <span style="color:red">圏(category)</span>とは
        </p>
        <ul>
          <li> 対象(object):$A,B,C,\cdots$ </li>
          <li> 射(arrow,morphism):$f,g,h,\cdots$ </li>
          <li> 射の合成(composition): $\circ$ </li>
        </ul>
        <p>
        からなり,以後の条件を全て満たすものである。
        </p>
        </section>

        <section>
        <p>
        任意の射$f$には
        </p>
        <ul>
          <li> 域(domain): $\mathrm{dom}(f)$ </li>
          <li> 余域(codomain): $\mathrm{cod}(f)$ </li>
        </ul>
        <p>
        という２つの対象が備わる。<br>
        $\mathrm{dom}(f) = A$,$\mathrm{cod}(f) = B$である事を $ f: A\rightarrow B$ と表す。
        </p>
        <div align="center"> <img src="fig/category1.png"> </div>
        </section>

        <section>
        <p> 射$f:A\rightarrow B$,$g:B\rightarrow C$が存在するならば, </p>
        <ul>
          <li> 合成射(composite)  $ g\circ f: A \rightarrow C $ </li>
        </ul>
        <p>
        も存在する。
        </p>
        <div align="center"> <img src="fig/category2.png"> </div>
        </section>

        <section>
        <p> 任意の射$f: A \rightarrow B$, $g: B \rightarrow C$, $h: C \rightarrow D$に対して<br> 結合律(associative law) </p>
        <div align="center"> $ (h\circ g)\circ f = h \circ (g\circ f)$ </div>
        <p> が成り立つ。すなわち,下図が可換である。</p>
        <div align="center"> <img height="55%" src="fig/category4.png"> </div>
        </section>

        <section>
        <p> 任意の対象$A$に対して </p>
        <ul>
          <li> 恒等射(identity) $ 1_A: A \rightarrow A $ </li>
        </ul>
        <p> が存在し,任意の$f: A \rightarrow B$に対して単位元律(identity law) </p>
        <div align="center"> $ f\circ 1_A = 1_B \circ f = f $ </div>
        <p> が成り立つ。すなわち,右下図が可換である。</p>
        <div align="center"> <img height="45%" src="fig/category3.png"> </div>
        </section>

        <section>
        <h3> 恒等射の一意性 </h3>
        <p>
        任意の対象$A$について，その恒等射は一意$1_A$に定まる。($1_A$と書く事ができるのはその為。)
        </p>

        <div class="fragment">
        <p style="font-size:80%">
        <img width="40%" src="fig/id_is_uniq.png" align="right" hspace="20">
        【一意性の証明】<br>
        $1_A,1'_A: A\rightarrow A$が共に恒等射だとする。<br>
        恒等射の性質より右図の上半分,下半分はどちらも可換だから
        $$ 1_A = 1'_A $$
        となる。つまり恒等射は一意に定まる。<span style="float:right">□</span>
        </p>
        </div>
        </section>

        <section id="isomorphism">
        <h3> 同型の定義 </h3>
        <p>
        $f: A\rightarrow B$に対して,$g: B\rightarrow A$が存在し,
        </p>
        <div align="center"> $ g\circ f = 1_A\qquad f\circ g = 1_B$ </div>
        <p>
        が成り立つならば$f$を<span style="color:red">同型射(isomorphism)</span>と呼ぶ。<br>
        また,圏$\mathbf{C}$において$A$と$B$の間に同型射が存在するならば,$\mathbf{C}$において$A$は$B$と<span style="color:red">同型(isomorphic)</span>であると言い,
        $$ A \cong B$$
        と表す。
        </p>
        <div align="center"><img src="fig/inverse.png"> </div>
        </section>

        <section id="inverse">
        <h3> 逆射 </h3>
        <p>
        $f: A\rightarrow B$が同型射ならば
        </p>
        <div align="center"> $ g\circ f = 1_A\qquad f\circ g = 1_B$ </div>
        <p>
        となる$g$は一意に定まる。このような$g$を<span style="color:red">逆射(inverse)</span>と言い$f^{-1}$と表す。
        </p>

        <div class="fragment">
        <p style="font-size:80%">
        <img width="50%" src="fig/inv_is_uniq5.png" align="right" hspace="20">
        【一意性の証明】<br>
        $g, h: B\rightarrow A$が$f$の逆射であるとすると右図が可換となるから,
        $$ g = h $$
        となる。つまり逆射は一意に定まる。
        <span style="float:right">□</span>
        </p>
        </div>
        </section>

        <section id="functor">
        <h3> 函手の定義 </h3>
        <p> 圏$\mathbf{C}$から圏$\mathbf{D}$への函手$F: \mathbf{C}\rightarrow\mathbf{D}$とは</p>
        <div align="left">
        <ul>
          <li> $\mathbf{C}$の各対象$A$に$\mathbf{D}$の対象$F(A)$を,</li>
          <li> $\mathbf{C}$の各射$f: A\rightarrow B$に$\mathbf{D}$の射$ F(f): F(A) \rightarrow F(B) $を</li>
        </ul>
        </div>
        <p> 対応付ける関数の組であり,以下の条件を満たすものである。 </p>
        <div align="left">
        <ul>
          <li> 任意の$\mathbf{C}$の射$f: A\rightarrow B$, $g: B\rightarrow C$に対して
          $$ F(g\circ f) = F(g) \circ F(f) $$
          </li>
          <li> 任意の$\mathbf{C}$の対象$A$に対して
          $$ F(1_A) = 1_{F(A)} $$
          </li>
        </ul>
        </div>
        </section>

        <section>
        <h3> 函手は可換図式を保つ </h3>
        <div align="left">
          <p>
          函手は合成射と恒等射を保つので,可換図式も保ちます。
          </p>
        </div>
        <div align="left" class="fragment" style="font-size:80%">
          <p>
          例えば,下図の上の図式が可換ならば下の図式も可換です。つまり,逆射も保たれますし,同型性も保たれます。
          $$ F(f^{-1}) = F(f)^{-1} \qquad A\cong B \Rightarrow F(A) \cong F(B)$$
          </p>
        <div align="center"><img height="50%" src="fig/inverse_is_preserved.png"> </div>
        </div>
        </section>

        <section>
        <h2> 圏の例 </h2>
        </section>

        <section>
        <h3> $\mathbf{1}$ </h3>
        <p>
        対象が1つ、射が恒等射のみの圏を<span style="color:red">$\mathbf{1}$</span>と表します。恒等射は必ず存在するので，下図では省略して描いています。
        </p>
        <div align="center"><img height="50%" src="fig/category-1.png"> </div>
        </section>

        <section>
        <h3> $\mathbf{2}$ </h2>
        <p>
        対象が２つ，恒等射以外の射が下図のよう1つある圏を<span style="color:red">$\mathbf{2}$</span>と表します。
        </p>
        <div align="center"><img height="50%" src="fig/category-2.png"> </div>
        </section>

        <section>
        <h3> $\mathbf{3}$ </h2>
        <p>
        対象が３つ，恒等射以外の射が下図のようになっている圏を<span style="color:red">$\mathbf{3}$</span>と表します。もちろん，斜めの射は他の２つの射の合成です。
        </p>
        <div align="center"><img height="50%" src="fig/category-3.png"> </div>
        </section>

        <section>
        <h3> 何の役に立つのか？ </h3>
        <p class="fragment">
        これらの圏それ自体はつまらないですが，これらの圏から任意の圏$\mathbf{C}$への函手が面白いです。
        </p>
        <div class="fragment" align="center"><img height="60%" src="fig/functor_from_123.png"> </div>
        </section>

        <section>
        <p>
        つまり，以下の事が言えます。
        </p>
        <ul>
          <li> $\mathbf{1}$から$\mathbf{C}$への函手は，$\mathbf{C}$の対象と一対一に対応。 </li>
          <li> $\mathbf{2}$から$\mathbf{C}$への函手は，$\mathbf{C}$の射と一対一に対応。 </li>
          <li> $\mathbf{3}$から$\mathbf{C}$への函手は，$\mathbf{C}$の合成可能な射の対と一対一に対応。 </li>
        </ul>
        <p class="fragment">
        このように<span style="color:red">函手と対象や射を同一視できる</span>という視点を持つ事はとても重要です。
        </p>
        </section>

        <section>
        <h3> 空圏 </h3>
        <p>
        対象も射も無い圏を<span style="color:red">空圏(empty category)</span>と言って<span style="color:red">$\mathbf{0}$</span>と表します。
        以下の事が言えます。<br>
        <ul>
          <li> 空圏から任意の圏$\mathbf{C}$へ函手が唯一つ存在する。</li>
          <li> 圏$\mathbf{C}$が空圏でないなら，$\mathbf{C}$から空圏への函手は存在しない。(対象・射の移り先が無い)</li>
        </ul>
        </p>
        <div align="center"><img height="40%" src="fig/category-0.png"> </div>
        </section>

        <section>
        <h3> 空関数 </h3>
        <p>
        <span style="color:red">空集合$\emptyset$から任意の集合への関数は唯一</span>です。この唯一の関数を<span style="color:red">空関数</span>と呼びます。
        空圏から任意の圏への函手が唯一つである事はこの事実から言えます。今後の為に覚えておきましょう。
        </p>
        <p class="fragment" style="font-size:80%">
        【説明】<br>
        集合$A$から$B$への関数は$A$,$B$の要素の対からなる集合$F$で，
        「任意の$x \in A$に対して$(x, y) \in F$となる$y\in B$が唯一つ存在する(※)」
        という条件を満たすもの(グラフと呼ぶ)によって定まります。$A = \emptyset$の場合には$A$の要素など存在しないのですから，
        $F = \emptyset$である事が必要で，さらに(※)は前提が偽なので真となります。したがってグラフが$\emptyset$しかないのですから対応する関数も唯一つとなります。
        </p>
        </section>

        <section>
        <h3> 離散圏 </h3>
        <p>
        全ての射が恒等射である圏を<span style="color:red">離散圏(discrete category)</span>と言います。
        恒等射は対象から決まるので，離散圏は対象の集合から一意に作れます。
        </p>
        <p class="fragment">
        つまり，<span style="color:red">離散圏とは集合</span>です。
        </p>
        <div align="center"><img height="50%" src="fig/discrete_category.png"> </div>
        </section>

        <section>
        <h3> モノイド </h3>
        <p>
        対象が1つである圏を<span style="color:red">モノイド(monoid)</span>と言います。<br>
        プログラミングの様々な場面で現れる重要な圏です。
        </p>
        <p class="fragment">
        「対象が1つ」$\Leftrightarrow$「全ての射が互いに合成可能」という事が重要で<span style="color:red">その対象が何なのかはどうでも良い</span>事が多いです。
        </p>
        <div align="center"><img height="50%" src="fig/monoid.png"> </div>
        </section>

        <section id="monoid">
        <h3> 圏を用いないモノイドの定義 </h3>
        <p>
        モノイドとは集合$M$，$M$上の二項演算$\circ$の組<span style="color:red">$(M, \circ)$</span>で，以下の条件を満たすものである。<br>
        <ul>
          <li>結合律: 任意の$x,y,z \in M$について
          $$ (x\circ y)\circ z = x\circ (y \circ z)$$
          </li>
          <li> 単位元の存在: ある$e \in M$が存在し,任意の$x \in M$について
          $$ e\circ x = x\circ e = x $$
          </li>
        </ul>
        </p>
        <p class="fragment">
        圏として解釈すると，$M$が射の集合,$\circ$が射の合成,$e$が恒等射に対応します。
        </p>
        </section>

        <section>
        <h3> モノイドの例:自然数と加法 </h3>
        <p>
        $\mathbb{N}$を$0$以上の自然数の集合,$+$を自然数の足し算としたとき,
        $$ (\mathbb{N}, +) $$
        はモノイドとなります。単位元は$0$です。
        </p>
        <div class="fragment">
        <p>
        <img align="right" height="50%" src="fig/monoid_nat_add.png">
        圏として描くと下図のように<span style="color:red">$\{0,1,2,3\cdots\}$が射</span>になります。
        (★は全部同じ対象です。)
        </p>
        </div>
        </section>

        <section>
        <h3> モノイドの例:加法・乗法によるモノイド </h3>
        <ul>
          <li> $(\mathbb{Z}, +),\quad(\mathbb{Q},+),\quad(\mathbb{R},+),\quad(\mathbb{C},+)$ </li>
          <li> $(\{0,2,4,8,\cdots\}, +),\quad(\{0,3,6,9,\cdots\}, +)$ </li>
          <li> $(\{\cdots,-10,-5,0,5,10,\cdots\},+)$ </li>
          <li> $(\{a+b\sqrt{2}|a,b\in \mathbb{Z}\}, +)$ </li>
          <li> $(\mathbb{Z}, \cdot),\quad(\mathbb{Q},\cdot),\quad(\mathbb{R},\cdot),\quad(\mathbb{C},\cdot)$ </li>
          <li> $(\{1,2,4,8,16,\cdots\},\cdot),\quad(\{1,3,9,27,\cdots\},\cdot)$ </li>
          <li> $(\{2^a3^b|a,b\in\mathbb{N}\},\cdot)$ </li>
          <li> $(\{1,-1,i,-i\}, \cdot)$ </li>
        </ul>
        $\vdots$
        </section>

        <section>
        <h3> モノイドの例:文字列と連結</h3>
        <p>
        文字列と文字列の連結
        $$ ({\tt String}, ++) $$
        はモノイドとなります。単位元は空文字列$\tt{""}$です。
        </p>
        <div align="center"><img height="50%" src="fig/monoid_string_append.png"></div>
        </section>

        <section>
        <h3> モノイドの例:リストと連結 </h3>
        <p>
        リスト型とリストの連結
        $$ ([A], ++) $$
        はモノイドとなります。単位元は空リスト$[\,]$です。
        </p>
        <div align="center"><img height="50%" src="fig/monoid_list_append.png"></div>
        </section>

        <section>
        <h3> モノイドの例: endofunction </h3>
        <p>
        ドメインとコドメインが同じ集合の関数$f: A\rightarrow A$を<span style="color:red">endofunction</span>と言います。
        </p>
        <p class="fragment">
        集合$A$上のendofunction全ての集合を$\mathrm{Endo}(A)$と表す事にすると,これと関数合成
        $$ (\mathrm{Endo}(A), \circ) $$
        はモノイドとなります。単位元は恒等関数$\mathrm{id}_A: A\rightarrow A$です。
        </p>
        </section>

        <section>
        <h3> モノイドの例: プログラム </h3>
        <p>
        プログラムを「文(statement)の列」と思うと,「何もしない文」を単位元とし「文を並べる事」を演算とするモノイドと見なせます。
        </p>
        <div align="center"><img height="50%" src="fig/monoid_program.png"></div>
        </section>

        <section>
        <h3> その他のモノイド </h3>
        <p>
        <ul> 
          <li> 論理積: $(\{\mathrm{true},\mathrm{false}\}, \mathrm{and})$ </li>
          <li> 論理和: $(\{\mathrm{true},\mathrm{false}\}, \mathrm{or})$ </li>
          <li> 集合のjoin: $(\mathcal{P}(A), \cup)$ </li>
          <li> 集合のmeet: $(\mathcal{P}(A), \cap)$ </li>
          <li> 最大値: $(\{0,1,2,\cdots,n\},\max)$ </li>
          <li> 最小値: $(\{0,1,2,\cdots,n\},\min)$ </li>
        </ul>
        </p>
        <p style="font-size:80%">
        $\mathcal{P}(A)$は$A$の部分集合全てからなる集合($A$のべき集合)です。例えば
        $$ \mathcal{P}(\{1,2,3\}) = \{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{2,3\},\{1,3\},\{1,2,3\}\}$$
        となります。
        </p>
        </section>

        <section>
        <h3> プログラミングでのモノイド </h3>
        <p>
        値の列を<span style="color:red">畳み込む</span>操作の多くはモノイド演算として抽象化できます。
        </p>
        <div align="center"><img height="50%" src="fig/folding.png"></div>
        </section>

        <section>
        <h3> プログラミングでのモノイド </h3>
        <p>
        GHC(Haskellの処理系)の<code>foldMap</code>という関数を使う例です。<span style="color:red">具体的な処理内容を書かなくても</span>,値をモノイド型にマッピングするだけで様々な畳み込みが出来ます。
        </p>
        <pre><code data-trim class="haskell" contenteditable>
% ghci
Prelude> :set prompt "> "
> :m +Data.Tree +Data.Monoid +Data.Foldable
> let tree = unfoldTree (\x -> (x, [1..x-1])) 5
> putStr . drawTree . fmap show $ tree
5
|
+- 1
|
+- 2
|  |
|  `- 1
|
+- 3
|  |
|  +- 1
|  |
|  `- 2
|     |
|     `- 1
|
`- 4
   |
   +- 1
   |
   +- 2
   |  |
   |  `- 1
   |
   `- 3
      |
      +- 1
      |
      `- 2
         |
         `- 1
> foldMap (\x -> [x]) tree
[5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
> foldMap show tree
"5121312141213121"
> foldMap Data.Set.singleton tree
fromList [1,2,3,4,5]
> foldMap Sum tree
Sum {getSum = 31}
> foldMap Product tree
Product {getProduct = 2880}
> foldMap (Sum . const 1) tree
Sum {getSum = 16}
> foldMap (All . (> 3)) tree
All {getAll = False}
> foldMap (Any . (> 3)) tree
Any {getAny = True}
> foldMap (Sum . fromEnum . (> 3)) tree
Sum {getSum = 2}
> foldMap (\x -> if even x then Just (Sum x) else Nothing) tree
Just (Sum {getSum = 12})
> foldMap (\x -> (Sum x, Product x)) tree
(Sum {getSum = 31},Product {getProduct = 2880})
> foldMap (First . (\x -> if even x then Just x else Nothing)) tree
First {getFirst = Just 2}
> foldMap (Last . (\x -> if even x then Just x else Nothing)) tree
Last {getLast = Just 2}
> foldMap (Last . (\x -> if odd x then Just x else Nothing)) tree
Last {getLast = Just 1}
> foldMap (First . (\x -> if odd x then Just x else Nothing)) tree
First {getFirst = Just 5}
> foldMap (fmap Sum . (\x -> if odd x then Just x else Nothing)) tree
Just (Sum {getSum = 19})
> foldMap (fmap Product . (\x -> if odd x then Just x else Nothing)) tree
Just (Product {getProduct = 45})
        </code></pre>
        </section>

        <section id="monoid-homomorphism">
        <h3> モノイド準同型(monoid homomorphism) </h3>
        <p>
        モノイド間の構造を保つマッピングを<span style="color:red">モノイド準同型(monoid homomorphism)</span>と言います。
        </p>
        <div style="border:1px solid #C0C0C0;padding:5px 5px 5px 5px">
        <p>
        モノイド$M=(|M|,\circ_M)$から$N=(|N|,\circ_N)$への準同型$F: M\rightarrow N$とは,関数$f: |M|\rightarrow |N|$で,以下の条件を満たすもの。<br>
        <ul>
          <li> $ f(x\circ_M y) = f(x)\circ_N f(y) $ </li>
          <li> $ f(e_M) = e_N \qquad (\text{$e_M$,$e_N$は$M$,$N$の単位元}) $ </li>
        </ul>
        </p>
        </div>
        <p class="fragment">
        モノイドを圏とみなした場合は,準同型とは関手の事です。
        </p>
        </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
        rollingLinks: false,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
      Reveal.addEventListener( 'slidechanged', function( event ) {
        MathJax.Hub.Rerender(event.currentSlide);
      });

		</script>

	</body>
</html>
