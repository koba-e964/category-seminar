<!doctype html>
<html lang="ja">

	<head>
		<meta charset="utf-8">

    <title>圏論勉強会 第2回 @ ワークスアプリケーションズ</title>

		<meta name="description" content="Seminar of category theory">
    <meta name="author" content="Koichi Nakamura">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

    <meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />

		<!-- For syntax highlighting -->
    <link rel="stylesheet" href="plugin/highlight/styles/github.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        }
      });
    </script>
    $$ \newcommand\append{{+\hspace{-.7em}+}} $$

    <style type="text/css">
      <!--
      div.definition {
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 4px solid #333333;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
      }
      div.theorem {
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 4px solid #333333;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
      }
      div.equation {
        margin: 10px;
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 2px solid #C0C0C0;
      }
      --> 
    </style>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

        <section>
        <h1>圏論勉強会<br>第2回</h1>
        <h3>@ワークスアプリケーションズ</h3>
        <small> 中村晃一 <br> 2013年5月23日</small>
        </section>

        <section>
        <h3>謝辞</h3>
        <p>
        この勉強会の企画，会場設備の提供をして頂きました<br>
        &#12849; ワークスアプリケーションズ様<br>
        にこの場をお借りして御礼申し上げます。
        </p>
        </section>

        <section>
        <h3> この会について </h3>
        <ul>
          <li> <span style="color:red">圏論(category theory)</span>を題材にいろんなことを学びます。</li>
          <li> 分かり易さを重視して初歩的な例を多用します。</li>
          <li> 関数型言語の経験がある方がより楽しめると思います。資料中では主にHaskellを使います。 </li>
          <li> この資料は<a href="http://nineties.github.com/category-seminar/">http://nineties.github.com/category-seminar</a>に置いてあります。</li>
        </ul>
        </section>

        <section>
        <h2> 第２回:モノイド・群 </h2>
        </section>

        <!--
        <section>
        <h3> 第2回の内容 </h3>
        <div class="fragment" align="center"> <img src="fig/pie_chart.png"> </div>
        </section>

        <section>
        <h1>モノイド勉強会</h1>
        <h3>@ワークスアプリケーションズ</h3>
        <small> 中村晃一 <br> 2013年5月23日</small>
        </section>
        -->

        <section>
        <h3> 第2回の内容 </h3>
        <p>
        本日は予定を変更して一旦圏論を離れ,モノイド・群という概念について紹介します。
        モノイド・群は「対象が$1$つの圏」でもありますので,本格的に圏論を学習する前に是非抑えておきたい内容です。
        </p>
        </section>

        <section>
        <h3> 用語・記法について </h3>
        <ul>
          <li> 自然数$\mathbb{N}$とは$0$以上の整数の事とします。 </li>
          <li> ２項演算子$\star$の第1引数,第2引数を定数に固定した関数を便宜的に以下の様に表す事にします。
          $$ \color{red}{(a\ \star)} : x \mapsto a \star x $$
          $$ \color{red}{(\star\ a)} : x \mapsto x \star a $$
          例えば
          $$ (2\ +)(3) = 2 + 3 \qquad (+\ 2)(3) = 3 + 2$$
          という感じです。
          </li>
        </ul>
        </section>

        <section>
        <h2> モノイド </h2>
        </section>

        <section id="monoid">
        <h3> モノイド </h3>
        <div class="definition">
        <p>
        <span style="color:red">モノイド(monoid)</span>とは集合$M$，$M$上の二項演算$\cdot$の組$(M, \cdot)$で，以下の条件を満たすものである。<br>
        </p>
        <ul>
          <li>結合律: 任意の$x,y,z \in M$について
          $$ (x\cdot y)\cdot z = x\cdot (y \cdot z)$$
          </li>
          <li> 単位元の存在: $e \in M$が存在し,任意の$x \in M$について
          $$ e\cdot x = x\cdot e = x $$
          </li>
        </ul><br>
        <p>
        $M$をこのモノイドの<span style="color:red">台集合(underlying set)</span>と言う。誤解の恐れがない場合にはモノイドと台集合に同じ記号を用いる。
        </p>
        </div>
        </section>

        <section>
        <h3> モノイド:自然数と加法 </h3>
        <p>
        $\mathbb{N}$を自然数の集合,$+$を整数の足し算としたとき,
        $$ (\mathbb{N}, +) $$
        はモノイドとなります。単位元は$0$です。
        </p>
        <p>
        モノイドの条件を全て満たす事を確認しましょう。<br>
        <div class="equation">
        <ul>
          <li> $x,y \in \mathbb{N}$ならば$x + y\in\mathbb{N}$ </li>
          <li> $(x + y) + z = x + (y + z)$ </li>
          <li> $0 + x = x + 0 = x$ </li>
        </ul>
        </div>
        </p>
        </section>

        <section>
        <h3> モノイド:自然数と乗法 </h3>
        <p>
        $\mathbb{N}$を自然数の集合,$\cdot $を整数の掛け算としたとき,
        $$ (\mathbb{N}, \cdot) $$
        はモノイドです。単位元は$1$です。
        </p>
        <div class="equation">
        <ul>
          <li> $x,y \in \mathbb{N}$ならば$x \cdot y\in\mathbb{N}$ </li>
          <li> $(x \cdot y) \cdot z = x \cdot (y \cdot z)$ </li>
          <li> $1 \cdot x = x \cdot 1 = x$ </li>
        </ul>
        </div>
        </section>

        <section>
        <h3> 加法・乗法によるモノイド </h3>
        <div align="left">
        <p> 加法については </p>
        <ul>
          <li> 整数$\mathbb{Z}$,有理数$\mathbb{Q}$,実数$\mathbb{R}$,複素数$\mathbb{C}$,$\cdots$ </li>
          <li> $2$の倍数,$3$の倍数,$\cdots$ </li>
          <li> $\{a+b\sqrt{2} | a,b\in \mathbb{Q}\}$ </li>
        </ul>
        <p> など。乗法については </p>
        <ul>
          <li> 整数$\mathbb{Z}$,有理数$\mathbb{Q}$,実数$\mathbb{R}$,複素数$\mathbb{C}$,$\cdots$ </li>
          <li> 正の自然数$\mathbb{N}^{+}$ </li>
          <li> $\{1,2,4,8,16,32,\cdots\}$ </li>
        </ul>
        <p> など、様々な集合がモノイドの条件を満たします。 </p>
        </div>
        </section>

        <section>
        <h3> モノイド:列と連結 </h3>
        <p>
        $[A]$を集合$A$を要素の有限列
        $$ [a_0, a_1,\cdots,a_n] \qquad (a_i \in A) $$
        とし,$\append$を列の結合
        $$ [a_0,\cdots,a_m]\append[b_0,\cdots,b_n] = [a_0,\cdots,a_m,b_0,\cdots,b_n] $$
        としたとき,$ ([A], \append) $はモノイドです。単位元は空列$[\,]$です。
        </p>
        <div class="equation">
        <ul>
          <li> $x,y \in [A]$ならば$x \append y\in [A]$ </li>
          <li> $(x \append y) \append z = x \append (y \append z)$ </li>
          <li> $[\,] \append x = x \append [\,] = x$ </li>
        </ul>
        </div>
        </section>

        <section>
        <h3> モノイド:文字列と連結 </h3>
        <p>
        「列」の一例として,文字列も連結に関してモノイドとなります。単位元は空文字列$\text{""}$です。
        </p>
        $$ \text{"Hello"} \append \text{" "} \append \text{"World!"} = \text{"Hello World!"} $$
        </section>

        <section>
        <h3> モノイド:論理積・論理和 </h3>
        <p> $(\{\mathrm{true},\mathrm{false}\}, \mathrm{and})$ 単位元は$\mathrm{true}$。</p>
        <div class="equation">
          $$\begin{aligned}
          &\mathrm{true}\ \mathrm{and}\ \mathrm{true}  = \mathrm{true} \\
          &\mathrm{true}\ \mathrm{and}\ \mathrm{false} = \mathrm{false}\ \mathrm{and}\ \mathrm{true} = \mathrm{false}
          \end{aligned}
          $$
        </div>
        <br>

        <p> $(\{\mathrm{true},\mathrm{false}\}, \mathrm{or})$  単位元は$\mathrm{false}$。</p>
        <div class="equation">
          $$\begin{aligned}
          & \mathrm{false}\ \mathrm{or}\ \mathrm{false}  = \mathrm{false} \\
          & \mathrm{false}\ \mathrm{or}\ \mathrm{true} = \mathrm{true}\ \mathrm{or}\ \mathrm{false} = \mathrm{true}
          \end{aligned}
          $$
        </div>
        </section>

        <section>
        <h3> モノイド:集合の$\mathrm{join}$,$\mathrm{meet}$ </h3>
        <p> $(\mathcal{P}(A), \cup)$ 単位元は$\emptyset$。</p>
        <div class="equation">
          $ X\cup\emptyset = \emptyset\cup X = X$
        </div>
        <br>

        <p> $(\mathcal{P}(A), \cap)$ 単位元は$A$。 </p>
        <div class="equation">
          $ X\cap A = A\cap X = X \quad (X\subseteq A) $
        </div>
        </ul>
        <p style="font-size:80%">
        $\mathcal{P}(A)$は$A$の部分集合全てからなる集合($A$のべき集合(power set))です。例えば
        $$ \mathcal{P}(\{1,2,3\}) = \{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{2,3\},\{1,3\},\{1,2,3\}\}$$
        のような集合です。
        </p>
        </section>

        <section>
        <h3> モノイド:最大値・最小値</h3>
        <p> $A$を最小値$m$を持つ数値の集合とすると,$(A, \max)$は$m$を単位元とするモノイドです。</p>
        <div class="equation">
          $\max\{m, x\} = \max\{x, m\} = x \quad (x \in A) $
        </div>
        <br>
        <p> $A$を最大値$M$を持つ数値の集合とすると,$(A, \min)$は$M$を単位元とするモノイドです。</p>
        <div class="equation">
          $\min\{M, x\} = \min\{x, M\} = x \quad (x \in A) $
        </div>
        </section>

        <section>
        <p>
        今の３つの例は「有界半束はモノイドである」という事実の具体例です。
        「束」は積・余積と関係するので後の回に説明します。本日は分からなくても大丈夫です。
        </p>
        </section>

        <section>
        <h3> プログラミングにおけるモノイド </h3>
        </section>

        <section>
        <h3> 集約演算 </h3>
        <p> データ列に対する集約・集積演算はモノイドと関係します。 </p>
        <ul>
          <li> 値の和・積を求める。 </li>
          <li> 条件を満たす要素を集める。 </li>
          <li> 最大値・最小値を計算する。 </li>
          <li> 全て～であるか？～を満たす物があるか？ </li>
        </ul>
        <p> 関数型言語では<span style="color:red">畳み込み(folding)</span>と呼ぶ事が多いです。</p>
        </section>

        <section>
        <p> 格納データを<span style="color:red">直列化</span>出来るコンテナに対して,モノイドによる畳込みを定義する事が出来ます。</p>
        <div align="center"> <img height="70%" src="fig/fold1.png"> </div>
        </section>

        <section>
        <p> モノイドの結合性は任意の部分列から畳み込む事を正当化しますので,効率のよいアルゴリズムを考える際に重要です。 </p>
        <div align="center"> <img height="70%" src="fig/fold2.png"> </div>
        </section>

        <section>
        <p> 都合良くモノイドな値を格納している事は少ないので,個々の値を適当なモノイドにマッピングする操作とセットで考えましょう。 </p>
        <div align="center"> <img height="70%" src="fig/fold3.png"> </div>
        </section>

        <section>
        <p> つまり,$\mathrm{map}$と$\mathrm{fold}$を合成した関数によって様々な畳み込みを行うことがはずです。 </p>
        <div align="center"> <img height="70%" src="fig/fold4.png"> </div>
        </section>

        <section>
        <h3> Haskellでの例 </h3>
        <pre><code data-trim class="haskell" contenteditable>
-- 当日Haskellでいくつか例をお見せします。
-- 使用したコードは後でここに反映させます。











        </code></pre>
        </section>

        <section>
        <!--
        <h3> とても便利ですね～</h3>
        -->
        <p class="fragment">
        冷静に考えるとまだよく分からない。
        <ul>
          <li class="fragment"> 足すとか掛けるとか,一種類の計算しか出来ないのか？ </li>
          <li class="fragment"> 何が出来て何が出来ないのか? </li>
        </ul>
        </p>
        </section>

        <section>
        <h3> 例えば絵を描くという作業 </h3>
        <img width="45%" src="fig/monoid_endofunction_example.png" align="right" hspace="20">
        <ul>
          <ol> 円を描いて </ol>
          <ol> 線を引いて </ol>
          <ol> 色を塗って </ol>
          <ol> ･･･ </ol>
        </ul><br clear="right">
        <p> 絵とは一連の作業の<span style="color:red">集積</span>では？ </p>
        </section>

        <section>
        <h3> 例えばロボットの操作 </h3>
        <img width="45%" src="fig/monoid_endofunction_example2.png" align="right" hspace="20">
        <ul>
          <ol> 右を向け </ol>
          <ol> 前へ進め </ol>
          <ol> 止まれ </ol>
          <ol> ・・・ </ol>
        </ul><br clear="right">
        <p> ロボットの動きとは一連の命令の<span style="color:red">集積</span>では？ </p>
        </section>

        <section>
        <h3> モノイド: endomorphism </h3>
        <img width="30%" src="fig/endomorphism.png" align="right" hspace="20">
        <p style="font-size:90%">
        ドメインとコドメインが同じ集合である関数を,<span style="color:red">自己準同型写像(endomorphism)</span>と言います。
        </p>
        <div class="fragment">
        <p style="font-size:90%">
        集合$A$上の自己準同型全ての集合は関数合成に関して,恒等関数$\mathrm{id}_A$を単位元とするモノイドです。
        このモノイドを$\color{red}{\mathrm{End}(A)}$と表すことにします。
        </p><br clear="right">
        <div class="equation">
          $$ \begin{aligned}
          & h\circ(g\circ f) = (h\circ g)\circ f \\
          & \mathrm{id}_A\circ f = f\circ \mathrm{id}_A = f
          \end{aligned}$$
        </div>
        </div>

        <div align="left" style="font-size:50%">
          注: 集合は全く構造のない代数系と見なせるので,後の事も考えて準同型と呼ぶことにします。
        </div>
        </section>

        <section>
        <h3> Haskellでの例 </h3>
        <pre><code data-trim class="haskell" contenteditable>
-- 当日Haskellでいくつか例をお見せします。
-- 使用したコードは後でここに反映させます。











        </code></pre>
        </section>

        <section>
        <h3> モノイドの表現 </h3>
        </section>

        <section>
        <p style="font-size:120%">
        もしかして,任意のモノイドは自己準同型のなすモノイドとして表せるのでは？
        </p>
        <div class="fragment" align="center"> <img src="fig/monoid_cayley.png"> </div>
        </section>

        <section>
        <p> いくつか言葉を準備して,この現象について考えてみます。 </p>
        <div align="center"> <img src="fig/monoid_cayley2.png"> </div>
        </section>

        <section>
        <h3> 準備: モノイド準同型 </h3>
        <p>
        モノイドからモノイドへの構造を保ったマッピングを(モノイドの)<span style="color:red">準同型写像(homomorphism)</span>と言います。「写像」を省略して準同型と呼びます。ところでモノイドの構造とは結合的な２項演算と単位元の事でした。
        </p>
        <div class="fragment">
        <div class="definition">
          <p>
          モノイド$(M,\star)$から$(N,\diamond)$への準同型$F: (M,\star) \rightarrow (N,\diamond)$とは,$M$から$N$への関数であり以下の条件を満たすもの。<br>
          <ul>
            <li> $ F(x\star y) = F(x)\diamond F(y)$ </li>
            <li> $ F(e_{\star}) = e_{\diamond}\quad(\text{$e_{\star}$,$e_{\diamond}$は各モノイドの単位元}) $ </li>
          </ul>
          </p>
        </div>
        </div>
        </section>

        <section>
        <h3> 準同型の例: $\mathrm{length}$ </h3>
        <p>
        有限列の長さを得る関数$\mathrm{length}$は準同型
        $$ \mathrm{length} : ([A],\append) \rightarrow (\mathbb{N},+) $$
        と見なせます。
        <br>
        <div class="equation">
        $$ \begin{aligned}
        &\mathrm{length}([a_0,\cdots,a_m]\append[b_0,\cdots,b_n]) \\
        &\quad = \mathrm{length}([a_0,\cdots,a_m]) + \mathrm{length}([b_0,\cdots,b_n]) \\
        &\mathrm{length}([\ ]) = 0
        \end{aligned} $$
        </div>
        </p>
        </section>

        <section>
        <h3> 準備: モノイドの同型 </h3>
        <p> 同型とは「本質的に同じ」という事です。</p>
        <div class="definition">
          <p>
          モノイド$M$から$N$への準同型$f: M\rightarrow N$に対して準同型$g: N\rightarrow M$が存在し,
          $$ g\circ f= \mathrm{id}_M \qquad f\circ g = \mathrm{id}_N $$
          である時,$f$を$M$から$N$への<span style="color:red">同型写像(isomorphism)</span>と言う。モノイド$M$と$N$の間に同型写像が存在する時,$M$と$N$は<span style="color:red">同型(isomorphic)</span>であると言い
          $$ M \cong N $$
          と表す。
          </p>
        </div>
        </section>

        <section>
        <h3> 同型の例: $x \mapsto a^x$ </h3>
        <div style="font-size:90%">
        <p>
        例えば$f(x) = 2^x$という関数は準同型
        $$ f: (\mathbb{N},+) \rightarrow (\{1,2,4,8,16,\cdots\},\cdot) $$
        と見なせます。
        </p>
        <div class="equation">
        $$ 2^{x+y} = 2^x\cdot 2^y \qquad 2^0 = 1 $$
        </div>
        <p>
        同様に$g(x) = \log_2 x$が逆方向の準同型を与え,
        $$ \log_2 2^x = x \qquad 2^{\log_2 x} = x $$
        なので$f$が同型写像である事が判ります。
        $$ (\mathbb{N},+) \cong (\{1,2,4,8,16,\cdots\},\cdot) $$
        </p>
        </div>
        </section>

        <section>
        <h3> 準備: 部分モノイド </h3>
        <div class="definition">
          <p>
        同じ演算からなるモノイド$(A, \cdot)$と$(B,\cdot)$について,$A \subseteq B$であるならば$A$は$B$の<span style="color:red">部分モノイド</span>であると言い
        $$ (A,\cdot) \subseteq (B,\cdot) $$
        と表す。
        </p>
        </div>
        <p>
        例えば,下のような例があります。
        $$(\{0,2,4,6,8,\cdots\},+) \subseteq (\mathbb{N}, +) \subseteq (\mathbb{Z}, +) $$
        </p>
        </section>

        <section>
        <h3> 定理 </h3>
        <div class="theorem">
        <p>
        任意のモノイドは適当な$\mathrm{End}{A}$の部分モノイドと同型。
        </p>
        </div>
        <div style="font-size:90%">
        <p class="fragment">
        この定理は「表現定理」と呼ばれる一連の定理の一つです。<br>
        「モノイド」というよく分からない抽象概念に「集合と関数」からなる具体的な表現を与える事によって,
        その正体が掴みやすくなるのです。今後の授業でも度々登場する重要なテーマです。
        </p>
        </div>
        </section>

        <section>
        <div align="left" style="font-size:80%">
        【証明】<br>
        <span class="fragment">モノイド$M=(\{a,b,\cdots\},\cdot)$に対して,$\overline{M} = \{(a\ \ \cdot),(b\ \ \cdot),\cdots\}$とする。$e\in M$を単位元とする。</span><span class="fragment">すると,任意の$a,b\in M$に対して</span>
        <ul>
          <li class="fragment"> 任意の$x\in M$について$((a\cdot b)\ \ \cdot)(x) = (a\ \ \cdot)\circ(b\ \ \cdot)(x) = a\cdot b\cdot x$ なので
          $$ ((a\cdot b)\ \ \cdot) = (a\ \ \cdot)\circ(b\ \ \cdot) $$
          </li>
          <li class="fragment"> 任意の$x\in M$について$(e\ \ \cdot)(x) = e\cdot x = x$なので
          $$ (e\ \ \cdot) = \mathrm{id}_{M} $$
          </li>
        </ul>
        <p class="fragment">
        すなわち$\phi: a\mapsto (a\ \ \cdot)$は$M$から$\overline{M}\subseteq\mathrm{End}(M)$への準同型を定める。
        </p>
        </div>
        </section>

        <section>
        <p> ここで$\overline{M}$から$M$への写像$\psi: f\mapsto f(e)$を考えると,</p>
        <ul>
          <li class="fragment"> 任意の$x \in M$について
          $$ \psi\circ \phi(x) = \psi((x\ \ \cdot)) = (x\ \ \cdot)(e) = x\cdot e = x$$
          </li>
          <li class="fragment"> 任意の$(x\ \ \cdot) \in \overline{M}$について
          $$ \phi\circ\psi(f) = \phi((x\ \ \cdot)(e)) = \phi(x) = (x\ \ \cdot)$$
          </li>
        </ul>
        <p class="fragment">
        すなわち
        $$ \psi\circ\phi = \mathrm{id}_{M}\qquad\phi\circ\psi = \mathrm{id}_{\overline{M}}$$
        となる。
        </p>
        <p class="fragment"> 従って$(M, \cdot) \cong (\overline{M}, \circ)$ <span style="float:right">□</span> </p>
        </section>

        <section>
        <p> 同様に$a\mapsto (\cdot\ \ a)$という同型写像を考える事も出来ます。ただし,畳み込みの順番を保つ為には関数合成の順番を逆にしたモノイド($\mathrm{End}(A)$の反モノイドと言います。)への写像を考える必要があります。
        </p>
        <div align="center"> <img src="fig/opposite_monoid_cayley.png"> </div>
        </section>

        <section>
        <h2> $\mathrm{foldr}と\mathrm{foldl}$ </h2>
        </section>

        <section>
        <p>
        関数型言語を勉強するとそのうち$\color{red}{\mathrm{foldr}}$,$\color{red}{\mathrm{foldl}}$という謎の関数に出くわします。この授業でも今後よく登場すると思います。
        </p>
        <p class="fragment">
        さて,名前から分かる様にこれも畳み込みを行う関数ですのでモノイドと関係があるはずです。
        今回はそのような視点からこれらを眺めてみます。
        </p>
        </section>

        <section>
        <h3> $\mathrm{foldr},\,\mathrm{foldl}$とは</h3>
        <p>
        $\mathrm{foldr}$は二項演算$\star : A\times B\rightarrow B$,$x \in B$を受け取り,$A$の要素の列を以下のように$B$の値に畳み込みます。
        </p>
        <p>
        同様に$\mathrm{foldl}$は二項演算$\diamond : B\times A\rightarrow B$,$x \in B$を受け取り,以下のように畳み込みます。
        </p>
        <div align="center"> <img src="fig/foldr_foldl.png"> </div>
        </section>

        <section>
        <p> 書きなおすと・・・</p>
        <div class="fragment" align="center"> <img src="fig/foldr_foldl2.png"> </div>
        <p class="fragment">
        つまり$\mathrm{foldr},\,\mathrm{foldl}$は、自己準同型へのマッピングと値の代入を一挙に行なってくれる関数という見方が出来ます。
        </p>
        <p class="fragment">
        すると表現定理から$\mathrm{foldMap}$で出来る事は全て$\mathrm{foldr},\,\mathrm{foldl}$でも出来るという事が言えます。
        </p>
        <p class="fragment">
        さらに$\star$,$\diamond$は<span style="color:red">モノイドの演算でなくても良い</span>のでより汎用性が高いのです。
        </p>
        </section>

        <section>
        <h3> Haskellでの例 </h3>
        <pre><code data-trim class="haskell" contenteditable>
-- 当日Haskellでいくつか例をお見せします。
-- 使用したコードは後でここに反映させます。











        </code></pre>
        </section>

        <section>
        <h3> 自由モノイド </h3>
        </section>

        <section>
        <p>
        $\mathrm{foldMap}\ f$という関数は列の各要素を$f$でマッピングしてから畳み込む関数でした。
        </p>
        <div align="center"> <img src="fig/foldMap_homomorphism.png"> </div>
        <p class="fragment">
        ところで連結演算によて<span style="color:red">列自体もモノイド</span>となります。すると$\mathrm{foldMap}\ f$はモノイド準同型と見なせます。
        </p>
        </section>

        <section>
        <h3> 自由モノイド </h3>
        <p>
        「畳込み」を「列に縮約演算を入れる事」だと思えば,全ての畳み込みが「列と連結」からのモノイド準同型として作れる事になります。つまり,「列と連結」は特別なモノイドです。
        </p>
        <p class="fragment">
        この事を$([A], \append)$は$A$上の<span style="color:red">自由モノイド(free monoid)</span>であると言います。
        </p>
        </section>

        <section>
        <h3> 抽象的な自由モノイドの定義が欲しい! </h3>
        <p>
        「列と連結」という自由モノイドの定義は非常に具体的です。<br>
        「もの」と「矢印」と「矢印の連結」よって定義を与える事が出来れば,後に圏論に進んだ際にモノイド以外の概念に応用できるはずです。
        </p>
        </section>

        <section>
        <h3> 自由モノイドの本質とは </h3>
        <p>
        任意の空でない列は下図のように長さ$1$の列に分解出来ます。一切の縮約演算が行われていないから,このような分解が出来るわけです。
        </p>
        <p>
        すると,任意長の列からの準同型は「長さ$1$列のマッピング」のみによって完全に決定されます。
        </p>
        <div align="center"> <img src="fig/free_monoid2.png"> </div>
        </section>

        <section>
        <p> これがまさに$\mathrm{foldMap}$という関数が行なっている事です。</p>
        </p>
        <div align="center"> <img src="fig/free_monoid1.png"> </div>
        </section>

        <section>
        <p>
        集合$A$の要素を長さ$1$の列にする関数を$i$とすると,下の図式が可換である事は
        $$ \mathrm{foldMap}\ f [a] = f(a) $$
        が任意の$a\in A$について成り立つという事です。<br>
        今説明したように,この可換図式が$\mathrm{foldMap}\ f$の機能を完全に決定します。(証明は後の回にやります。)
        </p>
        <div align="center"> <img height="30%" src="fig/free_monoid3.png"> </div>
        </section>

        <section id="free_monoid">
        <h3> 自由モノイドの定義 </h3>
        <div class="definition" style="font-size:80%">
        <p>
        モノイド$F(A)$が集合$A$上の自由モノイドであるとはそれがある関数$i: A\rightarrow F(A)$を備えており,任意の関数$f: A\rightarrow M$に対して下側の図式が可換となるようなモノイド準同型$\overline{f}: F(A)\rightarrow M$が唯一つ存在することである。
        </p>
        <div align="center"> <img height="40%" src="fig/free_monoid4.png"> </div>
        </div>
        <div align="left" style="font-size:50%">
          注: モノイドと台集合,準同型と台集合間の関数に同じ記号を使っています。記号の使い分けは圏論に入ってからにします。
        </div>
        </section>

        <!--
        <section>
        <h3> 最後に </h3>
        </section>

        <section>
        <h3> モノイド: プログラム </h3>
        <p>
        プログラムを「文(statement)の列」と思うと,「何もしない文」を単位元とし「文を並べる事」を演算とするモノイドと見なせます。
        </p>
        <div align="center"><img height="50%" src="fig/monoid_program.png"></div>
        </section>

        <section>
        <div align="left" style="font-size:150%">
          モナドは(ry
        </div>
        </section>
        -->

        <section>
        <h2> 未完 </h2>
        </section>

        <section>
        <h3> 第2回はここで終わります </h3>
        <p>
        お疲れ様でした。<br>
        圏論勉強会なのに圏論をやらずにすみませんでした。しかし,モノイドの理解があると圏論の学習もしやすくなります。
        いよいよ,次回は最初に戻って圏の定義から一歩ずつ進めて行きます。
        </p>
        </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
        rollingLinks: false,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
      Reveal.addEventListener( 'slidechanged', function( event ) {
        MathJax.Hub.Rerender(event.currentSlide);
      });

		</script>

	</body>
</html>
