<!doctype html>
<html lang="ja">

	<head>
		<meta charset="utf-8">

    <title>圏論勉強会 第4回 @ ワークスアプリケーションズ</title>

		<meta name="description" content="Seminar of category theory">
    <meta name="author" content="Koichi Nakamura">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

    <meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />

		<!-- For syntax highlighting -->
    <link rel="stylesheet" href="plugin/highlight/styles/github.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
        }
      });
    </script>

    <style type="text/css">
      <!--
      div.definition {
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 4px solid #333333;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
      }
      div.theorem {
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 4px solid #333333;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
      }
      div.equation {
        margin: 10px;
        padding-top: 10px;
        padding-bottom: 10px;
        padding-left: 10px;
        padding-right: 10px;
        border: 2px solid #C0C0C0;
      }
      --> 
    </style>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

        <section>
        <h1>圏論勉強会<br>第4回</h1>
        <h3>@ワークスアプリケーションズ</h3>
        <small> 中村晃一 <br> 2013年6月6日</small>
        $$ \newcommand\append{{+\hspace{-.7em}+}} $$
        </section>

        <section>
        <h3>謝辞</h3>
        <p>
        この勉強会の企画，会場設備の提供をして頂きました<br>
        &#12849; ワークスアプリケーションズ様<br>
        にこの場をお借りして御礼申し上げます。
        </p>
        </section>

        <section>
        <h3> この会について </h3>
        <ul>
          <li> <span style="color:red">圏論(category theory)</span>を題材にいろんなことを学びます。</li>
          <li> 分かり易さを重視して初歩的な例を多用します。</li>
          <li> 関数型言語の経験がある方がより楽しめると思います。資料中では主にHaskellを使います。 </li>
          <li> 中高生も数人見ているらしいのでプログラミングと関係が浅い内容も取り上げます。</li>
          <li> この資料は<a href="http://nineties.github.com/category-seminar/">http://nineties.github.com/category-seminar</a>に置いてあります。</li>
        </ul>
        </section>

        <section>
        <h2> 第4回: 射で考える </h2>
        </section>

        <section>
        <h3> 第4回の内容 </h3>
        <p>
        今回は様々な概念を「圏論の言葉のみで述べる」方法について見ていきます。
        つまり,「対象」の具体的な内部構造ではなく「射」を用いて物事を説明するという事です。
        </p>
        </section>

        <section>
        <h3> generalized element </h3>
        </section>

        <section>
        <h3> 集合の要素 </h3>
        <p>
        まず,圏$\mathbf{Sets}$を考えましょう。対象は集合、射は関数でした。
        </p>
        <p class="fragment">
        ここで<span style="color:red">集合の要素</span>を関数によって表現する事を考えます。
        </p>
        <div align="center"> <img src="fig/generalized_element6.png"> </div>
        </section>

        <section>
        <p>
        要素が一つの集合(singleton, unit set)を$1$と表す事にすると,<span style="color:red">$1$から集合$A$への関数</span>と$A$の要素が一対一に対応する事が判ります。
        </p>
        <p>
        $a \in A$に対応する関数を$\overline{a}$と表す事にします。
        </p>
        <div align="center"> <img width="70%" src="fig/generalized_element1.png"> </div>
        </section>

        <section>
        <p>
        この場合$f(a)$には$f\circ\overline{a} $が対応します。<br>
        つまり関数適用が関数合成に置き換わります。
        </p>
        <div align="center"> <img src="fig/generalized_element7.png"> </div>
        </section>

        <section>
        <h3> 射を要素と見なす </h3>
        <p>
        「要素が一つの集合」がまだ圏論的に定式化されていないですが,その前に<span style="color:red">射を対象の構成要素と見なす</span>考え方の例をいくつか見てみます。
        </p>
        </section>

        <section>
        <p>
        $2$点からなる集合($2$と表します)から集合$A$への関数は,$A$の要素の対と見なせます。<span style="font-size:80%">(前回紹介した$\mathbf{2}$という圏と混同しないように注意して下さい。)</span>
        </p>
        <div align="center"> <img src="fig/generalized_element2.png"> </div>
        </section>

        <section>
        <p>
        自然数の集合$\mathbb{N}$から実数の集合$\mathbb{R}$への関数は実数列と見なせます。
        </p>
        <div align="center"> <img src="fig/generalized_element3.png"> </div>
        </section>

        <section>
        <p>
        「半順序集合」と「単調関数」からなる圏における$\mathbb{N}$から$\mathbb{R}$への射は単調増加実数列と見なせます。
        </p>
        <div align="center"> <img src="fig/generalized_element9.png"> </div>
        </section>

        <section>
        <p>
        モノイドの圏$\mathbf{Mon}$における射(モノイド準同型)は,モノイドを別のモノイドの一部(部分モノイド)に移します。
        </p>
        <div align="center"> <img width="70%" src="fig/generalized_element10.png"> </div>
        </section>

        <section>
        <p>
        圏$\mathbf{1},\mathbf{2},\mathbf{3}$からの函手($\mathbf{Cat}$の射)が対象・射・合成可能対と見なせる事は前回見ました。
        </p>
        <div align="center"> <img width="70%" src="fig/functor_from_123.png"> </div>
        </section>

        <section>
        <p>
        $f$を適当なシンボルとした時「$f(\text{変数})$という形の項」は「変数の集合」から「項の集合」への関数で表せます。
        </p>
        <div align="center"> <img src="fig/generalized_element4.png"> </div>
        </section>

        <section>
        <p>
        自然数の集合は定数関数$\mathrm{zero}$と,後者関数$\mathrm{succ}$によって構成されていると考える事が出来ます。
        </p>
        <div align="center"> <img src="fig/generalized_element5.png"> </div>
        </section>

        <section>
        <p>
        Haskellにおける$\mathrm{Maybe}\ A$型は$\mathrm{Nothing}$という定数関数と,$\mathrm{Just}$という関数によって構成されていると考える事が出来ます。
        </p>
        <div align="center"> <img src="fig/generalized_element11.png"> </div>
        </section>

        <section>
        <h3> generalized element </h3>
        <p>
        このように,任意の対象$X$から対象$A$への任意の射$a: X\rightarrow A$は$A$の構成要素を表していると考える事が出来ます。この意味で射$a$の事を$A$の<span style="color:red">generalized element</span>と呼びます。
        </p>
        <div align="center"> <img src="fig/generalized_element8.png"> </div>
        </section>

        <section>
        <h3> 射で考える </h3>
        <p>
        圏論においては「射」が主役です。様々な概念を「射」によって解釈し,逆に「射」を「モノ」として解釈する視点を養う事が大事になります。
        </p>
        </section>

        <section>
        <h3> point-free style </h3>
        <p>
        関数型言語ではpoint-free styleという<span style="color:red">関数と合成のみでプログラムを書く</span>スタイルがあります。この場合のpoint(点)とは集合の要素の事です。
        </p>
        <p>
        人間が読むのには適していない場合もありますが,プログラムを圏論の枠組みで扱う場合に必要となります。
        </p>
        <pre><code data-trim class="haskell" contenteditable>
h x = f (g x)   -- not point-free

h = f . g       -- point-free
        </code></pre>
        </section>

        <section>
        <h3> Hom集合 </h3>
        </section>

        <section id="homset">
        <h3> Hom集合の定義 </h3>
        <div class="definition">
        <p>
        圏$\mathbf{C}$において,対象$A$から対象$B$への射全てからなる集合を
        $$ \mathrm{Hom}_{\mathbf{C}}(A,B) $$
        と表し,<span style="color:red">Hom集合(hom-set)</span>と言う。
        文脈から圏が明らかな場合には単に$\mathrm{Hom}(A,B)$と表す。
        </p>
        <div align="center"> <img src="fig/hom_set.png"> </div>
        </div>
        </section>

        <section>
        <h3> Hom集合の考え方 </h3>
        <p>
        Hom集合は様々な用途に用いますが,$\mathrm{Hom}(A,B)$をgeneralized elementの集合と思う視点は理解を助けます。
        </p>
        <p class="fragment">
        <img width="30%" align="right" src="fig/generalized_element1.png">
        例えば
        $$ \mathrm{Hom}_{\mathbf{Sets}}(1,A) $$
        は$A$の要素の集合($A$そのもの)と解釈でき,
        </p>
        <br clear="right">
        <p class="fragment">
        <img width="30%" align="right" src="fig/generalized_element2.png">
        $$ \mathrm{Hom}_{\mathbf{Sets}}(2,A) $$
        は$A$の要素の対の集合と解釈できます。
        </p>
        </section>

        <section>
        <h3> Hom函手 </h3>
        </section>

        <section>
        <p> 一般化して対象$X$を固定した時の<span style="color:red">対象$A$と$\mathrm{Hom}_{\mathbf{C}}(X,A)$の関係</span>について正確に述べる為の言葉を準備しておきます。
        </p>
        <div align="center"> <img src="fig/hom_functor.png"> </div>
        </section>

        <section id="covariant_hom_functor">
        <h3> 共変Hom函手 </h3>
        <div class="definition" style="font-size:85%">
        <p>
        $\mathbf{C}$の対象$X$を固定して
        </p>
        <ul>
          <li> $\mathbf{C}$の対象$A$に集合$\mathrm{Hom}(X, A)$ </li>
          <li> $\mathbf{C}$の射$f: A\rightarrow B$に,「左から$f$を合成する」という関数
          $$ \mathrm{Hom}(X, f): \mathrm{Hom}(X,A) \ni a \mapsto f\circ a \in\mathrm{Hom}(X, B)$$
          </li>
        </ul>
        <p>
        を対応させる事は函手,$ \mathrm{Hom}(X, -): \mathbf{C} \rightarrow \mathbf{Sets} $である。これを<span style="color:red">共変Hom函手(covariant hom-functor)</span>と言う。
        </p>
        <div align="center"> <img width="70%" src="fig/hom_functor1.png"> </div>
        </div>
        </section>

        <section>
        <p>
        「左から$f$を合成する」
        $$ a\longmapsto f\circ a$$
        という事は「関数$f$を適用する」
        $$ a\longmapsto f(a)$$
        という事の一般化であると思う事が出来ます。
        </p>
        </section>

        <section>
        <p>
        また,$\mathbf{C}$の要素が$1$つのときを考えてみると,前々回やったモノイドを自己準同型のなすモノイドに変換する操作はまさに共変Hom函手に対応しています。
        </p>
        <div align="center"> <img width="70%" src="fig/monoid_cayley.png"> </div>
        </section>

        <section>
        <h3> 函手である事の確認 </h3>
        <p> 見にくいので$f_{*} = \mathrm{Hom}(X, f)$と略記します。</p>
        <p class="fragment">
        まず、
        $$ \begin{aligned}
        & (f\circ g)_{*}(h) = (f\circ g)\circ h = f\circ g\circ h \\
        &f_{*}\circ g_{*}(h) = f_{*}(g\circ h) = f\circ (g\circ h) = f\circ g\circ h
        \end{aligned} $$
        なので<span style="color:red">$(f\circ g)_{*} = f_{*}\circ g_{*}$</span>です。
        <p>
        <p class="fragment">
        続いて,$1$を恒等射とすると
        $$ 1_{*}(f) = 1\circ f = f$$
        なので<span style="color:red">$1_{*}$は恒等関数</span>($\mathbf{Sets}$の恒等射)です。
        </p>
        <p class="fragment">
        という事で$\mathbf{Hom}(X, -)$は函手となります。
        </p>
        </section>

        <section>
        <p>
        今度は$\mathrm{Hom}(A,X)$の$X$の方を固定する事を考えて見ましょう。
        この場合対象$A$は$\mathrm{Hom}(A,X)$に移り,射$f: A\rightarrow B$は「右から$f$を合成する」という関数
        $$ \mathrm{Hom}(f, X): \mathrm{Hom}(B, X) \ni b \mapsto b\circ f \in \mathrm{Hom}(A,X)$$
        に移ります。
        </p>
        <p>
        この時,マッピングによって<span style="color:red">射の向きが逆になっている</span>事に注意しましょう。
        </p>
        <div align="center"> <img width="70%" src="fig/hom_functor2.png"> </div>
        </section>

        <section>
        <h3> 反変函手 </h3>
        <p> $f: A\rightarrow B$が$F(f): F(B)\rightarrow F(A)$に移り </p>
        <ul>
          <li> $F(f\circ g) = F(g)\circ F(f) $ </li>
          <li> $F(1_A) = 1_{F(A)}$ </li>
        </ul>
        <p>
        を満たす対象と射のマッピングを<span style="color:red">反変函手(contravariant functor)</span>と言います。
        </p>
        </section>

        <section>
        <h3> 反変函手 </h3>
        <p>
        $\mathbf{C}$から$\mathbf{D}$への反変函手は,$\mathbf{C}$の双対圏$\mathbf{C}^{\mathrm{op}}$から$D$への共変函手になっているので
        $$ F: \mathbf{C}^{\mathrm{op}} \rightarrow \mathbf{D}$$
        と表記することにします。
        </p>
        <div align="center"> <img width="50%" src="fig/contravariant_functor.png"> </div>
        </section>

        <section id="contravariant_hom_functor">
        <h3> 反変Hom函手 </h3>
        <div class="definition" style="font-size:85%">
        <p>
        $\mathbf{C}$の対象$X$を固定して
        </p>
        <ul>
          <li> $\mathbf{C}$の対象$A$に集合$\mathrm{Hom}(A, X)$ </li>
          <li> $\mathbf{C}$の射$f: A\rightarrow B$に,「右から$f$を合成する」という関数
          $$ \mathrm{Hom}(f, X): \mathrm{Hom}(B,X) \ni b \mapsto b\circ f \in\mathrm{Hom}(X, A)$$
          </li>
        </ul>
        <p>
        を対応させる事は函手,$ \mathrm{Hom}(-, X): \mathbf{C}^{\mathrm{op}} \rightarrow \mathbf{Sets} $である。これを<span style="color:red">反変Hom函手(contravariant hom-functor)</span>と言う。
        </p>
        <div align="center"> <img width="70%" src="fig/hom_functor3.png"> </div>
        </div>
        </section>

        <section>
        <p> 反変Hom函手が実際に反変函手になっている事の証明は,共変Hom函手の場合と同様なので省略します。やってみて下さい。</p>
        </section>

        <section>
        <h3> 終対象・始対象 </h3>
        </section>

        <section>
        <h3> 単集合の抽象化 </h3>
        <p> generalized elementの所で要素が一つの集合(単集合)が登場しましたがこれの一般化を考えます。
        まず$\mathbf{Sets}$の場合を考えましょう。
        </p>
        <div class="fragment">
          <p>
          任意の集合$A$から単集合$1$への関数を考えてみると,それは「$A$の全ての要素を$1$の一点に移す」という<span style="color:red">唯一つの関数</span>しかない事が判ります。これによって単集合を説明出来そうです。
        </p>
        <div align="center"> <img width="70%" src="fig/final_object.png"> </div>
        </p>
        </section>

        <section id="final_object">
        <h3> 終対象 </h3>
        <div class="definition">
        <p>
        ある対象$1$が<span style="color:red">終対象(final object)</span>であるとは,
        任意の対象$A$から$1$への射が唯一つ存在する事である。
        </p>
        <div align="center"> <img width="40%" src="fig/final_object2.png"> </div>
        </div>
        </section>

        <section>
        <h3> 終対象は同型を除いて一意 </h3>
        <p style="font-size:90%">
        【証明】<br>
        終対象が2つ($1$と$1'$)存在すると仮定すると,終対象の条件より射$f: 1\rightarrow 1'$と$g:1'\rightarrow 1$が存在する。すると,$g\circ f$と$1_1$が共に$1$から$1$への射となるが,$1$は終対象なのだからこれらは等しい。すなわち
        $$ g\circ f = 1_1$$
        である。同様に$ f\circ g = 1_{1'}$であるので$f,g$は同型射である。従って
        $$ 1 \cong 1' $$
        であるから終対象は同型を除いて一意に定まる。<span style="float:right">□</span> </p>
        </p>
        <div align="center"> <img width="60%" src="fig/final_object_is_unique.png"> </div>
        </section>

        <section>
        <p>
        「概念$X$とは条件$C$を満たすものである」という形で何かを定式化すると$X$の実体には複数の選択肢が存在し得る事になります。この時,具体的な実体は<span style="color:red">何を選んでも良い</span>という事でないと概念$X$を一意に定義したとは言えません。
        </p>
        <p class="fragment">
        「同型を除いて一意」であるならば、具体的な実体を特定せずに矛盾なく圏論の議論を進める事が出来る事になります。
        </p>
        <p class="fragment">
        プログラマ向けに分かりやすく言うと「具体的な実装方法に依存しない議論が可能」という事です。
        </p>
        </section>

        <section id="initial_object">
        <h3> 始対象 </h3>
        <div class="definition">
        <p>
        ある対象$0$が<span style="color:red">始対象(initial object)</span>であるとは,
        $0$から任意の対象$A$への射が唯一つ存在する事である。
        </p>
        <div align="center"> <img width="40%" src="fig/initial_object.png"> </div>
        </div>
        <p class="fragment">
        始対象とは双対圏$\mathbf{C}^{\mathrm{op}}$における終対象です。始対象と終対象は「互いに双対である」などと表現します。
        </p>
        <p class="fragment">
        すると終対象が同型を除いて一意であることから,自動的に始対象も同型を除いて一意である事が示されます。
        </p>
        </section>

        <section>
        <h3> $\mathbf{Sets}$の始対象と終対象 </h3>
        <p>
        $\mathbf{Sets}$では
        </p>
        <img align="right" width="50%" src="fig/sets_initial_final.png">
        <ul>
          <li> 始対象: 空集合 </li>
          <li> 終対象: 単集合 </li>
        </ul>
        <p>
        となります。
        </p>
        </section>

        <section>
        <h3> $\mathbf{Mon}$の始対象と終対象 </h3>
        <p>
        モノイドは必ず単位元を含みますので,空集合がモノイドとなる事はありません。そこで<span style="color:red">単位元のみのモノイド</span>$(\{e\},\cdot)$を考えるとこれが始対象でありかつ終対象です。
        </p>
        <ul>
          <li> 始対象であること: 単位元を単位元に移す </li>
          <li> 終対象であること: 全ての元を単位元に移す </li>
        </ul>
        <p>
        始対象かつ終対象である対象を<span style="color:red">ヌル対象(null object)</span>とも呼びます。
        </p>
        </section>

        <section>
        <h3> $(\mathbb{N}, \leqq)$の始対象と終対象 </h3>
        <p>
        全順序集合$(\mathbb{N}, \leqq)$をそれ単体で圏とみなした場合は
        </p>
        <ul>
          <li> 始対象: $0$ </li>
          <li> 終対象: 存在しない </li>
        </ul>
        <p>
        となります。
        </p>
        <div align="center"> <img src="fig/natural_ordering.png"> </div>
        </section>

        <section>
        <h3> $\mathbf{Cat}$の始対象と終対象 </h3>
        <p>
        前回紹介した空圏$\mathbf{0}$と$\mathbf{1}$がそれぞれ始対象・終対象となります。
        </p>
        </section>

        <section>
        <p>
        他にも様々な例がありますが,時間の都合上割愛します。今後必要に応じて紹介します。
        興味のある圏の始対象や終対象がもし存在するなら何であるのか考えてみると良いでしょう。
        </p>
        </section>

        <section>
        <h3> 極限 </h3>
        </section>

        <section>
        <p>
        第１回では積・余積という構成を紹介しました。ここではその構成方法の一般化を説明したいと思います。
        </p>
        </section>

        <section id="product">
        <h3> 積の定義</h3>
        <div class="definition">
        <p>
        対象$A$,$B$の積とは対象$P$,射$p_1: P\rightarrow A$，$p_2: P\rightarrow B$からなり,
        任意の対象$X$と任意の射$f: X\rightarrow A$, $g: X\rightarrow B$に対して，以下の図式が可換となるような
        $u: X\rightarrow P$が唯一つ存在するものである。
        </p>
        <div align="center"> <img src="fig/product.png"> </div>
        </div>
        </section>

        <section>
        <p>
        積の定義は「任意の～について～を満たす<span style="color:red">$P$へ向かう射</span>が唯一つ存在する」という,終対象の定義と同じ形式になっています。
        </p>
        <p>
        上手く圏を構成すれば「積とは圏～の終対象である」と一言で述べる事が出来そうです。
        </p>
        </section>

        <section>
        <p>
        まず,$A$,$B$を固定して以下の<span style="color:red">図式が対象</span>である圏を考えます。
        </p>
        <div align="center"> <img src="fig/limit2.png"> </div>
        <p>
        この時の射は,
        </p>
        <div align="center"> <img src="fig/limit3.png"> </div>
        </section>

        <section id="coproduct">
        <h3> 余積の定義</h3>
        <div class="definition">
        <p>
        対象$A$,$B$の余積とは対象$Q$,射$q_1: A\rightarrow Q$，$q_2: B\rightarrow Q$からなり,
        任意の対象$X$と任意の射$f: A\rightarrow X$, $g: B\rightarrow X$に対して，以下の図式が可換となるような
        $u: Q\rightarrow X$が唯一つ存在するものである。
        </p>
        <div align="center"> <img src="fig/coproduct.png"> </div>
        </div>
        </section>

        <section>
        積・余積
        </section>

        <section>
        <h3> イコライザ・コイコライザ </h3>
        </section>

        <section>
        <h3> 引き戻し・押出し </h3>
        </section>

        <section>
        <h3> 第4回はここで終わります </h3>
        <p>
        お疲れ様でした。<br>
        </p>
        </section>


			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
        rollingLinks: false,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
      Reveal.addEventListener( 'slidechanged', function( event ) {
        MathJax.Hub.Rerender(event.currentSlide);
      });

		</script>

	</body>
</html>
